[{"content":" STL中常用算法 # STL中定义了常用的一些算法，比如遍历，查找，排序等一些算法。\n遍历 # for_each 查找 # count_if # 函数原型为count_if(v.begin(),v.end(),comp)\nv.begin()为开始，v.end()为结束，comp为自定义判断函数。\n举个例子：\n排序 # 复制与拷贝 # 算术生成 # 集合算法 # ","externalUrl":null,"permalink":"/posts/chapter01/cpp-stl-argo/","section":"Posts","summary":"STL中常用算法 # STL中定义了常用的一些算法，比如遍历，查找，排序等一些算法。","title":"STL中常用算法","type":"posts"},{"content":" 时间复杂度 # 对数 ： 每轮排除一半情况 常用于二分法 指数：每轮分别出两倍情况 线性对数：一般为两层循环相互独立，一层为n一层为对数 常常出现在快速排序 空间复杂度 # 位运算 # 位运算有（\u0026amp;、|、^、~、\u0026raquo;、\u0026laquo;）这几种方法，以下为正且位数相同的二进制数进行的位运算，但是还会有其他特殊情况，比如二进制数非正，位数不同的情况。\n符号 描述 运算规则 \u0026amp; 与 两个位都为1时，结果才为1 | 或 两个位都为0时，结果才为0 ^ 异或 两个位相同为0，相异为1 ~ 取反 0变1，1变0 \u0026laquo; 左移 各二进位全部左移若干位，高位丢弃，低位补0 \u0026raquo; 右移 各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不同 按位与运算符（\u0026amp;） # 定义：参加运算的两个数据，按二进制位进行\u0026quot;与\u0026quot;运算。\n运算规则：同时为1才为1，\n0\u0026amp;0=0 0\u0026amp;1=0 1\u0026amp;0=0 1\u0026amp;1=1 //两位同时为1，结果才为1，否则结果为0。 例如：5\u0026amp;7 即 0000 0101\u0026amp; 0000 0111 = 0000 0101，因此 5\u0026amp;7 的值为5。\n注意：负数按补码形式参加按位与运算。\n与运算的用途：\n清零 如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。 取一个数的指定位 比如取数 X=1011 1001 的低4位，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行按位与运算（X\u0026amp;Y=0000 1001）即可得到X的指定位。 判断奇偶 二进制的奇偶数只需要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用if ((a \u0026amp; 1) == 0)代替if (a % 2 == 0)来判断a是不是偶数。 按位或运算符（|） # 定义：参加运算的两个对象，按二进制位进行\u0026quot;或\u0026quot;运算。\n运算规则：有1就为1，\n0|0=0 0|1=1 1|0=1 1|1=1 //参加运算的两个对象只要有一个为1，其值为1。 例如：5|7即 0000 0101| 0000 0111 = 0000 0111，因此，5|7的值得7。　注意：负数按补码形式参加按位或运算。\n或运算的用途：\n常用来对一个数据的某些位设置为1 比如将数 X=1010 1001 的低4位设置为1，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行按位或运算（X|Y=1010 1001）即可得到。 异或运算符（^） # 定义：参加运算的两个数据，按二进制位进行\u0026quot;异或\u0026quot;运算。\n运算规则：不同为1，相同为0\n0^0=0 0^1=1 1^0=1 1^1=0 //参加运算的两个对象，如果两个相应位相同为0，相异为1。 异或的几条性质:\n1、交换律 2、结合律 (a^b)^c == a^(b^c) 3、对于任何数x，都有 x^x=0，x^0=x 4、自反性: a^b^b=a^0=a; 异或运算的用途：\n翻转指定位 比如将数 X=1010 1110 的低4位进行翻转，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行异或运算（X^Y=1010 0001）即可得到。\n与0相异或值不变 例如：1010 1110 ^ 0000 0000 = 1010 1110\n交换两个数 例：(不使用中间变量，但是只能只能交换整型)\nvoid Swap(int \u0026amp;a, int \u0026amp;b){ if (a != b){ a ^= b; b ^= a; a ^= b; } } 取反运算符 (~) # 定义：参加运算的一个数据，按二进制进行\u0026quot;取反\u0026quot;运算。\n运算规则：　直接取反\n~1=0 ~0=1 //对一个二进制数按位取反，即将0变1，1变0。 异或运算的用途：\n使一个数的最低位为零 使a的最低位为0，可以表示为：a \u0026amp; ~1。~1的值为 1111 1111 1111 1110，再按\u0026quot;与\u0026quot;运算，最低位一定为0。 因为\u0026quot; ~\u0026ldquo;运算符的优先级比算术运算符、关系运算符、逻辑运算符和其他运算符都高。 左移运算符（\u0026laquo;） # 定义：将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。\n设 a=1010 1110，a = a\u0026laquo; 2 将a的二进制位左移2位、右补0，即得a=1011 1000。\n若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2。\n右移运算符（\u0026raquo;） # 定义：将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。\n例如：a=a\u0026raquo;2 将a的二进制位右移2位，左补0 或者 左补1得看被移数是正还是负。\n操作数每右移一位，相当于该数除以2。\n复合赋值运算符 # 位运算符与赋值运算符结合，组成新的复合赋值运算符，它们是：\n\u0026amp;= 例：a\u0026amp;=b 相当于 a=a\u0026amp;b |= 例：a|=b 相当于 a=a|b \u0026gt;\u0026gt;= 例：a\u0026gt;\u0026gt;=b 相当于 a=a\u0026gt;\u0026gt;b \u0026lt;\u0026lt;= 例：a\u0026lt;\u0026lt;=b 相当于 a=a\u0026lt;\u0026lt;b ^= 例：a^=b 相当于 a=a^b 运算规则：和前面讲的复合赋值运算符的运算规则相似。\n不同长度的数据进行位运算：如果两个不同长度的数据进行位运算时，系统会将二者按右端对齐，然后进行位运算。\n","externalUrl":null,"permalink":"/posts/chapter01/datastru/","section":"Posts","summary":"时间复杂度 # 对数 ： 每轮排除一半情况 常用于二分法 指数：每轮分别出两倍情况 线性对数：一般为两层循环相互独立，一层为n一层为对数 常常出现在快速排序 空间复杂度 # 位运算 # 位运算有（\u0026amp;、|、^、~、\u0026raquo;、\u0026laquo;）这几种方法，以下为正且位数相同的二进制数进行的位运算，但是还会有其他特殊情况，比如二进制数非正，位数不同的情况。","title":"常用算法储备知识","type":"posts"},{"content":" 什么是C++标准模板库（STL）？ # 标准模板库 STL（Standard Template Library），是 C++ 标准库的一部分，不需要单独安装，只需要#include 头文件。\nC++ 对模板（Template）支持得很好，STL 就是借助模板把常用的数据结构及其算法都实现了一遍，并且做到了数据结构和算法的分离。\nC++ 语言的核心优势之一就是便于软件的复用。\nC++ 语言有两个方面体现了复用：\n面向对象的继承和多态机制 通过模板的概念实现了对泛型程序设计的支持 C++中的模板，就好比英语作文的模板，只换主题，不换句式和结构。对应到C++模板，就是只换类型，不换方法。\nSTL有什么优势？ # STL封装了很多实用的容器，省时省力，能够让你将更多心思放到解决问题的步骤上，而非费力去实现数据结构诸多细节上，像极了用python时候的酣畅淋漓。\nSTL到底有什么？ # 六大部件:\n容器 分配器 算法 迭代器 适配器 仿函数 自定义 # vector 矢量 # 定义 # 使用前需添加头文件\n#include\u0026lt;vector\u0026gt; using namespace std; 像定义变量一样定义vector变量：\nvector\u0026lt;类型名\u0026gt; 变量名; 类型名可以是int、double、char、struct，也可以是STL容器：vector、set、queue。\nvector\u0026lt;int\u0026gt; name; vector\u0026lt;double\u0026gt; name; vector\u0026lt;char\u0026gt; name; vector\u0026lt;struct node\u0026gt; name; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; name; vector数组就是一个一维数组,如果定义成vector数组的数组，那就是二维数组**。**\nvector\u0026lt;int\u0026gt; array[SZIE]; //二维变长数组 在此，我送你一句话非常受用的话：低维是高维的地址。\n二维数组中，它的一维形式就是地址。例如：\n#include \u0026lt;iostream\u0026gt; using namespace std; int main(){ int arr[3][2];//定义一个3行2列的地址 cout\u0026lt;\u0026lt;arr[0]\u0026lt;\u0026lt;endl; //输出arr第1行的地址 cout\u0026lt;\u0026lt;arr[1]\u0026lt;\u0026lt;endl; //输出arr第2行的地址 cout\u0026lt;\u0026lt;arr[2]\u0026lt;\u0026lt;endl; //输出arr第3行的地址 return 0; } 输出：\n0x61fe00 //arr第1行的地址 0x61fe08 //arr第2行的地址 0x61fe10 //arr第3行的地址 所以，vector容器也可以这样理解。\n常用函数 # 1.构造函数 # vector():创建一个空vector vector(int nSize):创建一个vector,元素个数为nSize vector(int nSize,const t\u0026amp; t):创建一个vector，元素个数为nSize,且值均为t vector(const vector\u0026amp;):复制构造函数 vector(begin,end):复制[begin,end)区间内另一个数组的元素到vector中 2.增加函数 # void push_back(const T\u0026amp; x):向量尾部增加一个元素X iterator insert(iterator it,const T\u0026amp; x):向量中迭代器指向元素前增加一个元素x iterator insert(iterator it,int n,const T\u0026amp; x):向量中迭代器指向元素前增加n个相同的元素x iterator insert(iterator it,const_iterator first,const_iterator last):向量中迭代器指向元素前插入另一个相同类型向量的[first,last)间的数据 3.删除函数 # iterator erase(iterator it):删除向量中迭代器指向元素 iterator erase(iterator first,iterator last):删除向量中[first,last)中元素 void pop_back():删除向量中最后一个元素 void clear():清空向量中所有元素 4.遍历函数 # reference at(int pos):返回pos位置元素的引用 reference front():返回首元素的引用 reference back():返回尾元素的引用 iterator begin():返回向量头指针，指向第一个元素 iterator end():返回向量尾指针，指向向量最后一个元素的下一个位置 reverse_iterator rbegin():反向迭代器，指向最后一个元素 reverse_iterator rend():反向迭代器，指向第一个元素之前的位置 5.判断函数 # bool empty() const:判断向量是否为空，若为空，则向量中无元素 6.大小函数 # int size() const:返回向量中元素的个数 int capacity() const:返回当前向量所能容纳的最大元素值 int max_size() const:返回最大可允许的vector元素数量值 7.其他函数 # void swap(vector\u0026amp;):交换两个同类型向量的数据 void assign(int n,const T\u0026amp; x):设置向量中前n个元素的值为x void assign(const_iterator first,const_iterator last):向量中[first,last)中元素设置成当前向量元素 访问容器内元素 # vector一般有两种访问方式：\n（1）通过下标访问\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; vi; vi.push_back(1); cout\u0026lt;\u0026lt;vi[0]\u0026lt;\u0026lt;endl; return 0; } 输出：\n1 （2）通过迭代器访问\n迭代器（iterator）可以理解为指针：\nvector\u0026lt;类型名\u0026gt;::iterator 变量名; 例如：\nvector\u0026lt;int\u0026gt;::iterator it; vector\u0026lt;double\u0026gt;::iterator it; 举个例子：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 5; i++) { v.push_back(i); } //v.begin()返回v的首元素地址 vector\u0026lt;int\u0026gt;::iterator it=v.begin(); for (int i = 0; i \u0026lt; v.size(); i++) { cout\u0026lt;\u0026lt;it[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } return 0; } 输出：\n0 1 2 3 4 for循环迭代部分也可以写成：\nvector\u0026lt;int\u0026gt;::iterator it=v.begin(); for (int i = 0; i \u0026lt; v.size(); i++) { cout\u0026lt;\u0026lt;*(it+i)\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } 也即是\nit[i] = *(it+i) //这两个写法等价 这是简单的常识，以后不再提及。\n与此同时，迭代器与for循环还有一种优雅的写法。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 5; i++) { v.push_back(i); } //vector的迭代器不支持it\u0026lt;v.end()的写法，因此循环条件只能it!=v.end() for (vector\u0026lt;int\u0026gt;::iterator it=v.begin(); it!=v.end();it++) { cout\u0026lt;\u0026lt;*it\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } return 0; } 此种写法与遍历字符串有异曲同工之妙：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ string str; str=\u0026#34;Hello World\u0026#34;; for (int i = 0; str[i]!=\u0026#39;\\0\u0026#39;; i++) { cout\u0026lt;\u0026lt;str[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } return 0; } 输出：\nH e l l o W o r l d vector常用函数实例解析 # push_back() pop_back() size() clear() insert() erase() （1）push_back()\nvoid std::vector\u0026lt;int\u0026gt;::push_back(const int \u0026amp;__x) 见名知意，push_back(item)就是在vector后面添加一个元素item。\n用例：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 5; i++) { v.push_back(i); } for (int i = 0; i \u0026lt; v.size(); i++) { cout\u0026lt;\u0026lt;v[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } return 0; } 以前还要为定长数组内存分配而苦恼时，现在只需要无脑push_back()就好了。\n（2）pop_back()\nvoid std::vector\u0026lt;int\u0026gt;::pop_back() push和pop时一对反义词，学过数据结构的人都知道，栈元素的压入和弹出就是push和pop。\n须知，pop_back()一次弹出一个元素，vector容器就会减少一个预算。\n之所以叫容器，就是能往里面装一个一个的元素。\n用例：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 5; i++) { v.push_back(i); } cout\u0026lt;\u0026lt;\u0026#34;pop_back前:\u0026#34;\u0026lt;\u0026lt;endl; for (int i = 0; i \u0026lt; v.size(); i++) { cout\u0026lt;\u0026lt;v[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; v.pop_back(); cout\u0026lt;\u0026lt;\u0026#34;pop_back后:\u0026#34;\u0026lt;\u0026lt;endl; for (int i = 0; i \u0026lt; v.size(); i++) { cout\u0026lt;\u0026lt;v[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } return 0; } 输出：\npop_back前: 0 1 2 3 4 pop_back后: 0 1 2 3 （3）size()\nstd::size_t std::vector\u0026lt;int\u0026gt;::size() szie()返回vector中所含元素的个数，时间复杂度为O(1)。\n用例：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 5; i++) { v.push_back(i); } cout\u0026lt;\u0026lt;v.size()\u0026lt;\u0026lt;endl; return 0; } 输出：\n5 （4）clear()\nvoid std::vector\u0026lt;int\u0026gt;::clear() clear()用于一键清空vector中的所有元素，时间复杂度为O(N)，其中N为vector中原属和元素的个数。\n用例：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 5; i++) { v.push_back(i); } for (int i = 0; i \u0026lt; v.size(); i++) { cout\u0026lt;\u0026lt;v[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } v.clear(); cout\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;size = \u0026#34;\u0026lt;\u0026lt;v.size()\u0026lt;\u0026lt;endl; return 0; } 输出：\n0 1 2 3 4 size = 0 （5）insert()\ninsert(__position,__x); insert(要插入的地址，要插入的元素); 参数： __position：– A const_iterator into the %vector. __x:– Data to be inserted. 与push_back()无脑在尾部添加元素不同的是，insert()是根据指定位置在vector中插入元素。\n用例：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 5; i++) { v.push_back(i); } for (int i = 0; i \u0026lt; v.size(); i++) { cout\u0026lt;\u0026lt;v[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } v.insert(v.begin()+2,-1); //将-1插入v[2]的位置 cout\u0026lt;\u0026lt;endl; for (int i = 0; i \u0026lt; v.size(); i++) { cout\u0026lt;\u0026lt;v[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } return 0; } 输出：\n0 1 2 3 4 0 1 -1 2 3 4 （6）erase()\nerase(__position); 同样，与clear()简单粗暴清空vector不同的是erase()，删除指定位置的元素。\nerase()有两种用法：\n删除一个元素 删除一个区间内的元素 1.删除一个元素\nerase(__position); 用例：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 5; i++) { v.push_back(i); } for (int i = 0; i \u0026lt; v.size(); i++) { cout\u0026lt;\u0026lt;v[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } //删除v[3] v.erase(v.begin()+3); cout\u0026lt;\u0026lt;endl; for (int i = 0; i \u0026lt; v.size(); i++) { cout\u0026lt;\u0026lt;v[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } return 0; } 输出：\n0 1 2 3 4 0 1 2 4 2.删除一个区间内的元素\nerase(__positionBegin,__positionEnd); 即是删除[__positionBegin, __positionEnd)区间内的元素，注意：是左闭右开！\n用例：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 5; i++) { v.push_back(i); } for (int i = 0; i \u0026lt; v.size(); i++) { cout\u0026lt;\u0026lt;v[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } //删除v[1]到v[4]的元素 v.erase(v.begin()+1,v.begin()+4); cout\u0026lt;\u0026lt;endl; for (int i = 0; i \u0026lt; v.size(); i++) { cout\u0026lt;\u0026lt;v[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } return 0; } 输出：\n0 1 2 3 4 0 4 vector常见用途 # （1）储存数据\nvector本身可以作为数组使用，而且在一些元素个数不确定的场合可以很好地节省空间。\n（2）用邻接表存储图\n使用vector实现邻接表，更为简单。\nset # set（集合），是一个内部自动有序且不含重复元素的容器。\nset可以在需要去重复元素的情况大放异彩，节省时间，减少思维量。\n要使用set，需要添加头文件：\n#include \u0026lt;set\u0026gt; using namespace std; 定义 # 像定义变量一样定义set变量：\nset\u0026lt;类型名\u0026gt; 变量名; 类型名可以是int、double、char、struct，也可以是STL容器：vector、set、queue。\n用例：\nset\u0026lt;int\u0026gt; name; set\u0026lt;double\u0026gt; name; set\u0026lt;char\u0026gt; name; set\u0026lt;struct node\u0026gt; name; set\u0026lt;set\u0026lt;int\u0026gt;\u0026gt; name; set数组的定义和vector相同：\nset\u0026lt;类型名\u0026gt; array[SIZE]; 例如：\nset\u0026lt;int\u0026gt; arr[10]; 访问set容器内的元素 # set只能通过迭代器(iterator)访问：\nset\u0026lt;int\u0026gt;::iterator it; set\u0026lt;char\u0026gt;::iterator it; 这样，就得到了迭代器it，并且可以通过*it来访问set里的元素。\n注意：\n除了vector和string之外的STL容器都不支持*(it+i)的访问方式，因此只能按照如下方式枚举：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; int main() { set\u0026lt;int\u0026gt; st; st.insert(5); st.insert(2); st.insert(6); for (set\u0026lt;int\u0026gt;::iterator it = st.begin(); it != st.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; } return 0; } 输出：\n2 5 6 我们可以看到，原本无序的元素，被插入set集合后，set内部的元素自动递增排序，并且自动去除了重复元素。\nset常用函数实例解析 # （1）insert()\n插入元素十分简单。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; int main() { set\u0026lt;char\u0026gt; st; st.insert(\u0026#39;C\u0026#39;); st.insert(\u0026#39;B\u0026#39;); st.insert(\u0026#39;A\u0026#39;); for (set\u0026lt;char\u0026gt;::iterator it = st.begin(); it != st.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; } return 0; } （2）find()\nfind(value)返回的是set中value所对应的迭代器，也就是value的指针（地址）。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; int main() { set\u0026lt;int\u0026gt; st; for (int i = 1; i \u0026lt;= 3; i++) { st.insert(i); } set\u0026lt;int\u0026gt;::iterator it = st.find(2); //在set中查找2，返回其迭代器 cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; // 以上可以直接x携程 cout \u0026lt;\u0026lt; *(st.find(2)) \u0026lt;\u0026lt; endl; return 0; } 输出：\n2 2 （3）erase()\nerase()有两种用法：删除单个元素、删除一个区间内的所有元素。\n1.删除单个元素\n删除单个元素有两种方法：\nst.erase(it)，其中it为所需要删除元素的迭代器。时间复杂度为O(1)。可以结合find()函数来使用。 #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; int main() { set\u0026lt;int\u0026gt; st; st.insert(100); st.insert(200); st.insert(100); st.insert(300); // 删除单个元素 st.erase(st.find(100)); //利用find()函数找到100,然后用erase删除它 st.erase(st.find(200)); for (set\u0026lt;int\u0026gt;::iterator it = st.begin(); it != st.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; } return 0; } 输出：\n300 st.erase(value)，value为所需要删除元素的值。其时间复杂度为O(logN)，N为set内的元素个数。 #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; int main() { set\u0026lt;int\u0026gt; st; st.insert(100); st.insert(200); st.insert(100); st.insert(300); // 删除单个元素 st.erase(100); for (set\u0026lt;int\u0026gt;::iterator it = st.begin(); it != st.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; } return 0; } 输出：\n200 300 2.删除一个区间内的所有元素\nst.erase(iteratorBegin , iteratorEnd)可以删除一个区间内的所有元素。\n其中iteratorBegin为所需要删除区间的起始迭代器\niteratorEnd为所需要删除区间的结束迭代器的下一个地址\n也即是**[iteratorBegin,iteratorEnd)**\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; //2.删除一个区间内的所有元素 int main() { set\u0026lt;int\u0026gt; st; st.insert(100); st.insert(200); st.insert(100); st.insert(300); set\u0026lt;int\u0026gt;::iterator it = st.find(200); st.erase(it, st.end()); for (it = st.begin(); it != st.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; } return 0; } 输出：\n100 （4）size()\n不难理解，szie()用来实时获得set内元素的个数，时间复杂度为O(1)。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; int main() { set\u0026lt;int\u0026gt; st; st.insert(2); st.insert(5); st.insert(4); cout \u0026lt;\u0026lt; st.size() \u0026lt;\u0026lt; endl; return 0; } 输出：\n3 string # map # 定义 # map # map\u0026lt;int,int\u0026gt; maps; 相关函数 # maps.insert() 插入 maps[key] = value;数组方式插入 maps.find(num) 查找一个元素 maps.clear()清空 maps.szie()长度 maps.begin()返回指向map头部的迭代器 maps.end()返回指向map末尾的迭代器 maps.erase(num)删除一个元素。 unordered_map # 与map容器仅有一点不同的是，unordered_map是无序的。其底层采用的是哈希表存储，不会自动对存储的键值对进行排序。\nqueue # priority # stack # pair # algorithm # ","date":"10 November 2022","externalUrl":null,"permalink":"/posts/chapter01/cpp-stl-intro/","section":"Posts","summary":"什么是C++标准模板库（STL）？ # 标准模板库 STL（Standard Template Library），是 C++ 标准库的一部分，不需要单独安装，只需要#include 头文件。","title":"C++ STL","type":"posts"},{"content":"","externalUrl":null,"permalink":"/posts/chapter02/acwing/base/","section":"Posts","summary":"","title":"","type":"posts"},{"content":"","date":"10 November 2022","externalUrl":null,"permalink":"/posts/chapter01/","section":"Posts","summary":"","title":"第一章|基础知识储备","type":"posts"},{"content":"你好，欢迎访问！我是一名计算机科学专业的研究生，日常会写一些笔记，分享一些事情。\n包括一些个人笔记，一些记录等。\n这是是近期在做的一些事情\n后续内容我慢慢写\nw 当你引用本站点文章时，请加上本站链接并注明。 全部文章 STL中常用算法 \u0026middot;\u0026middot; 常用算法储备知识 \u0026middot;\u0026middot; C++ STL \u0026middot;\u0026middot; Vue3概述 \u0026middot;\u0026middot; \u0026middot;\u0026middot; \u0026middot;\u0026middot; \u0026middot;\u0026middot; \u0026middot;\u0026middot; \u0026middot;\u0026middot; \u0026middot;\u0026middot; \u0026middot;\u0026middot; \u0026middot;\u0026middot; \u0026middot;\u0026middot; \u0026middot;\u0026middot; \u0026middot;\u0026middot; \u0026middot;\u0026middot; \u0026middot;\u0026middot; \u0026middot;\u0026middot; \u0026middot;\u0026middot; \u0026middot;\u0026middot; \u0026middot;\u0026middot; \u0026middot;\u0026middot; \u0026middot;\u0026middot; \u0026middot;\u0026middot; \u0026middot;\u0026middot; shadcn \u0026middot;\u0026middot; vue组件开发 \u0026middot;\u0026middot; 全部文章 初始化 \u0026middot;\u0026middot; 后端技术 基础算法一 \u0026middot;\u0026middot; 搜索与图论 \u0026middot;\u0026middot; 数学相关问题 \u0026middot;\u0026middot; 数据科学 数据结构 \u0026middot;\u0026middot; 算法竞赛常用STL \u0026middot;\u0026middot; 背包问题 \u0026middot;\u0026middot; 贪心 \u0026middot;\u0026middot; 问题汇总 \u0026middot;\u0026middot; ","date":"10 November 2022","externalUrl":null,"permalink":"/","section":"首页","summary":"你好，欢迎访问！我是一名计算机科学专业的研究生，日常会写一些笔记，分享一些事情。","title":"首页","type":"page"},{"content":"","externalUrl":null,"permalink":"/posts/chapter02/acwing/","section":"Posts","summary":"","title":"Acwing","type":"posts"},{"content":"","externalUrl":null,"permalink":"/posts/chapter02/","section":"Posts","summary":"","title":"第二章|基础算法","type":"posts"},{"content":"","date":"10 November 2022","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"11 October 2022","externalUrl":null,"permalink":"/engineering/","section":"Engineerings","summary":"","title":"Engineerings","type":"engineering"},{"content":" Vue3.x # 官方文档：Vue.js - 渐进式 JavaScript 框架 | Vue.js\n什么是 Vue？ # Vue (发音为 /vjuː/，类似 view) 是一款用于构建用户界面的 JavaScript 框架。它基于标准 HTML、CSS 和 JavaScript 构建，并提供了一套声明式的、组件化的编程模型，帮助你高效地开发用户界面。无论是简单还是复杂的界面，Vue 都可以胜任。\n下面是一个最基本的示例：\nimport { createApp } from \u0026#39;vue\u0026#39; createApp({ data() { return { count: 0 } } }).mount(\u0026#39;#app\u0026#39;) template\n\u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;button @click=\u0026#34;count++\u0026#34;\u0026gt; Count is: {{ count }} \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; 上面的示例展示了 Vue 的两个核心功能：\n声明式渲染：Vue 基于标准 HTML 拓展了一套模板语法，使得我们可以声明式地描述最终输出的 HTML 和 JavaScript 状态之间的关系。 响应性：Vue 会自动跟踪 JavaScript 状态变化并在改变发生时响应式地更新 DOM。 你可能已经有了些疑问——先别急，后面的文档中我们会详细介绍每一个细节。现在，请继续看下去，以确保你对 Vue 作为一个框架到底提供了什么有一个宏观的了解。\n渐进式框架# # Vue 是一个框架，也是一个生态。其功能覆盖了大部分前端开发常见的需求。但 Web 世界是十分多样化的，不同的开发者在 Web 上构建的东西可能在形式和规模上会有很大的不同。考虑到这一点，Vue 的设计非常注重灵活性和“可以被逐步集成”这个特点。根据你的需求场景，你可以用不同的方式使用 Vue：\n无需构建步骤，渐进式增强静态的 HTML 在任何页面中作为 Web Components 嵌入 单页应用 (SPA) 全栈 / 服务端渲染 (SSR) Jamstack / 静态站点生成 (SSG) 开发桌面端、移动端、WebGL，甚至是命令行终端中的界面 如果你是初学者，可能会觉得这些概念有些复杂。别担心！理解教程和指南的内容只需要具备基础的 HTML 和 JavaScript 知识。你即使不是这些方面的专家，也能够跟上。\n如果你是有经验的开发者，希望了解如何以最合适的方式在项目中引入 Vue，或者是对上述的这些概念感到好奇，我们在使用 Vue 的多种方式中讨论了有关它们的更多细节。\n无论再怎么灵活，Vue 的核心知识在所有这些用例中都是通用的。即使你现在只是一个初学者，随着你的不断成长，到未来有能力实现更复杂的项目时，这一路上获得的知识依然会适用。如果你已经是一个老手，你可以根据实际场景来选择使用 Vue 的最佳方式，在各种场景下都可以保持同样的开发效率。这就是为什么我们将 Vue 称为“渐进式框架”：它是一个可以与你共同成长、适应你不同需求的框架。\n单文件组件 # 在大多数启用了构建工具的 Vue 项目中，我们可以使用一种类似 HTML 格式的文件来书写 Vue 组件，它被称为单文件组件 (也被称为 *.vue 文件，英文 Single-File Components，缩写为 SFC)。顾名思义，Vue 的单文件组件会将一个组件的逻辑 (JavaScript)，模板 (HTML) 和样式 (CSS) 封装在同一个文件里。下面我们将用单文件组件的格式重写上面的计数器示例：\n\u0026lt;script\u0026gt; export default { data() { return { count: 0 } } } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;button @click=\u0026#34;count++\u0026#34;\u0026gt;Count is: {{ count }}\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style scoped\u0026gt; button { font-weight: bold; } \u0026lt;/style\u0026gt; 单文件组件是 Vue 的标志性功能。如果你的用例需要进行构建，我们推荐用它来编写 Vue 组件。你可以在后续相关章节里了解更多关于单文件组件的用法及用途。但你暂时只需要知道 Vue 会帮忙处理所有这些构建工具的配置就好。\nAPI 风格# # Vue 的组件可以按两种不同的风格书写：选项式 API 和组合式 API。\n选项式 API (Options API)# # 使用选项式 API，我们可以用包含多个选项的对象来描述组件的逻辑，例如 data、methods 和 mounted。选项所定义的属性都会暴露在函数内部的 this 上，它会指向当前的组件实例。\n\u0026lt;script\u0026gt; export default { // data() 返回的属性将会成为响应式的状态 // 并且暴露在 `this` 上 data() { return { count: 0 } }, // methods 是一些用来更改状态与触发更新的函数 // 它们可以在模板中作为事件监听器绑定 methods: { increment() { this.count++ } }, // 生命周期钩子会在组件生命周期的各个不同阶段被调用 // 例如这个函数就会在组件挂载完成后被调用 mounted() { console.log(`The initial count is ${this.count}.`) } } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;button @click=\u0026#34;increment\u0026#34;\u0026gt;Count is: {{ count }}\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; 在演练场中尝试一下\n组合式 API (Composition API) # 通过组合式 API，我们可以使用导入的 API 函数来描述组件逻辑。在单文件组件中，组合式 API 通常会与 \u0026lt;script setup\u0026gt;搭配使用。这个 setup attribute 是一个标识，告诉 Vue 需要在编译时进行一些处理，让我们可以更简洁地使用组合式 API。比如，\u0026lt;script setup\u0026gt; 中的导入和顶层变量/函数都能够在模板中直接使用。\n下面是使用了组合式 API 与 \u0026lt;script setup\u0026gt; 改造后和上面的模板完全一样的组件：\n\u0026lt;script setup\u0026gt; import { ref, onMounted } from \u0026#39;vue\u0026#39; // 响应式状态 const count = ref(0) // 用来修改状态、触发更新的函数 function increment() { count.value++ } // 生命周期钩子 onMounted(() =\u0026gt; { console.log(`The initial count is ${count.value}.`) }) \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;button @click=\u0026#34;increment\u0026#34;\u0026gt;Count is: {{ count }}\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; 在演练场中尝试一下\n该选哪一个？ # 两种 API 风格都能够覆盖大部分的应用场景。它们只是同一个底层系统所提供的两套不同的接口。实际上，选项式 API 是在组合式 API 的基础上实现的！关于 Vue 的基础概念和知识在它们之间都是通用的。\n选项式 API 以“组件实例”的概念为中心 (即上述例子中的 this)，对于有面向对象语言背景的用户来说，这通常与基于类的心智模型更为一致。同时，它将响应性相关的细节抽象出来，并强制按照选项来组织代码，从而对初学者而言更为友好。\n组合式 API 的核心思想是直接在函数作用域内定义响应式状态变量，并将从多个函数中得到的状态组合起来处理复杂问题。这种形式更加自由，也需要你对 Vue 的响应式系统有更深的理解才能高效使用。相应的，它的灵活性也使得组织和重用逻辑的模式变得更加强大。\n在组合式 API FAQ 章节中，你可以了解更多关于这两种 API 风格的对比以及组合式 API 所带来的潜在收益。\n如果你是使用 Vue 的新手，这里是我们的大致建议：\n在学习的过程中，推荐采用更易于自己理解的风格。再强调一下，大部分的核心概念在这两种风格之间都是通用的。熟悉了一种风格以后，你也能够很快地理解另一种风格。 在生产项目中： 当你不需要使用构建工具，或者打算主要在低复杂度的场景中使用 Vue，例如渐进增强的应用场景，推荐采用选项式 API。 当你打算用 Vue 构建完整的单页应用，推荐采用组合式 API + 单文件组件。 在学习阶段，你不必只固守一种风格。在接下来的文档中我们会为你提供一系列两种风格的代码供你参考，你可以随时通过左上角的 API 风格偏好来做切换。\n","date":"11 October 2022","externalUrl":null,"permalink":"/engineering/frontend/vue/vue/","section":"Engineerings","summary":"Vue3.","title":"Vue3概述","type":"engineering"},{"content":" 前端 # 主要有UI框架、CSS框架、JavaScript框架：\nUI框架：\nAnt Design RadixUI \u0026hellip; CSS框架：\nTailWindCSS \u0026hellip; JavaScript框架：\nReact Vue \u0026hellip;. ","date":"11 October 2022","externalUrl":null,"permalink":"/engineering/frontend/","section":"Engineerings","summary":"前端 # 主要有UI框架、CSS框架、JavaScript框架：","title":"前端技术","type":"engineering"},{"content":"这是关于页面\n这是首页 正视自己，分析问题。 记录在案!\n道理是曲折的 若将容易得，便作等闲看。 12345678904026\n首先贴一个 github 热力图，激励坚持每日写作更新吧!\n这是哪?是干嘛的?🤔 # 这是个笔记本，什么东西都可能在上边记录。\n自用\n包括一些什么内容？ # 算法学习心得 计算机基础 其他内容 一些提问自问自答 # 为什么要学计算机基础？ # 作为考研党，408 内容囊括了计算机基础的大部分内容，包括计算机如何运行，电脑如何工作，数据如何处理，传输，是基本功；如果不懂基础，你可能会错失很多乐趣。这些内容也被人称为八股文，即工作用不到，考试还喜欢考的“死记硬背”的知识，但其实你自己专门学习后，会发现这些其实很有趣，也很有用。\n为什么要写算法题？ # 写算法题和写数学题一样，通过不断训练来锻炼对于各类数据结构、各类算法思想的使用，从而提高个人的编程水平。\n关于 408 # 选择题 40 2 = 80 分 综合题 70 分 两个数据结构，两个计组，两个操作系统，一个计算机网络。\n人活一世都不容易，年纪轻轻就有这种想法了？\n追求你想要的，守护你在乎的。\n","externalUrl":null,"permalink":"/about/","section":"首页","summary":"这是关于页面","title":"","type":"page"},{"content":" NextAuth鉴权 # callback\nuseSession检测是否登录的最快方法\n只在客户端使用 NextAuth.js 客户端中的 useSession（） React Hook 是检查某人是否已登录的最简单方法。\n","externalUrl":null,"permalink":"/engineering/auth/reademe/","section":"Engineerings","summary":"NextAuth鉴权 # callback","title":"","type":"engineering"},{"content":"一些脚手架工具\nNextJS # ","externalUrl":null,"permalink":"/engineering/frontend/react/clis/","section":"Engineerings","summary":"一些脚手架工具","title":"","type":"engineering"},{"content":"","externalUrl":null,"permalink":"/engineering/frontend/react/readme/","section":"Engineerings","summary":"","title":"","type":"engineering"},{"content":" 准备Android环境 # 1. 安装 Android Studio​ # 首先下载和安装 Android Studio，国内用户可能无法打开官方链接，请自行使用搜索引擎搜索可用的下载链接。安装界面中选择\u0026quot;Custom\u0026quot;选项，确保选中了以下几项：\nAndroid SDK Android SDK Platform Android Virtual Device 然后点击\u0026quot;Next\u0026quot;来安装选中的组件。\n以下是项目初始化 先卸载之前可能装过的\nnpm uninstall -g react-native-cli @react-native-community/cli 然后重新安装\nnpx react-native@latest init AwesomeProject 然后 等ing\n长时间没用了会报错 记得升级一下node 直接去官网下最新版安装就好 2023-12-28T01:11:00+08:00\n项目出来了 先用Android Studio打开目录下Android文件夹 安装一下依赖.\n移动端开发 # expo调试 可以windows调试iOS！！！！！！！！ 大进步\n官网React Native 里面有文档教程 可能会有坑\nnode 最新版 双数版本官网 LTS长期稳定版 前端必备的 不多说\nAndroid Studio 安卓开发必备\n需要安装以下环境包\nAndroid SDK\nAndroid SDK Platform\nXCode iOS开发必备\nJdk 安卓本身是基于Java的 所以jdk是必须的，还有JRE 这两个别放一个路径下，能用就不用折腾了\nIDE 我用的VSCode 后边可能试试webstorm\n注意事项，常见问题 # 学会使用文心一言\nhttps://yiyan.baidu.com/\nDoctor # React-native有个好工具 就是排查哪部分有错误\n在目录下的终端输入 npx react-native doctor\n如果没有npx 也可以装一个，适用于出错后来排查，如果已经可以运行了 但是他还是会有error，比如我的。\n关于安卓环境包的安装 # Android SDK\nAndroid SDK Platform\n配置参考我的\nbuildscript { ext { buildToolsVersion = \u0026#34;31.0.1\u0026#34;//工具版本 minSdkVersion = 21 compileSdkVersion = 33 targetSdkVersion = 33 if (System.properties[\u0026#39;os.arch\u0026#39;] == \u0026#34;aarch64\u0026#34;) { ndkVersion = \u0026#34;24.0.8215888\u0026#34; } else { ndkVersion = \u0026#34;21.4.7075529\u0026#34; } } repositories { maven { url \u0026#39;https://maven.aliyun.com/repository/google\u0026#39; } maven {url \u0026#39;https://maven.aliyun.com/repository/public\u0026#39;} // maven { url \u0026#39;https://maven.aliyun.com/repository/jcenter\u0026#39; }这个用不了换为jcenter google() mavenCentral() jcenter() } dependencies { classpath(\u0026#39;com.android.tools.build:gradle:8.1.3\u0026#39;) classpath(\u0026#34;com.facebook.react:react-native-gradle-plugin\u0026#34;) classpath(\u0026#34;de.undercouch:gradle-download-task:5.0.1\u0026#34;) } } allprojects { repositories { maven { // All of React Native (JS, Obj-C sources, Android binaries) is installed from npm url(\u0026#34;$rootDir/../node_modules/react-native/android\u0026#34;) } maven { // Android JSC is installed from npm url(\u0026#34;$rootDir/../node_modules/jsc-android/dist\u0026#34;) }} // } maven { url \u0026#39;https://maven.aliyun.com/repository/public\u0026#39; } maven { url \u0026#39;https://maven.aliyun.com/repository/google\u0026#39; } maven { url \u0026#39;https://www.jitpack.io\u0026#39; } } } 版本\n往下翻\n注意 如果没换gradle路径的话 可能会装到C盘 占用二十多G，如果c盘内存不多可以换一下路径。\n怎么换呢\nAwesomeProject\\android\\gradle\\wrapper\\gradle-wrapper.properties 这个文件中就告诉你\n它是在GRADLE_USER_HOME这个位置去找 所以在环境变量中添加这个项目 然后指向你想要的位置（其他盘）然后把原来的删了就行了。\n真机调试 # 没试过电脑上装虚拟安卓机，就用自己手机调试，用数据线连上然后打开开发者模式（打开方式每个品牌手机都不一样，如果有选择充电还是传文件的，选择传文件，不然无法在手机上装app）。\n然后打开终端Terminal 输入 adb devices\n前边都装好了 连上电脑 然后打开Android Studio 和 前端IDE 然输入 npm run start 选择安卓 就自动会给手机装app 然后IDE更改代码 手机端的app也会及时更新修改。\n","externalUrl":null,"permalink":"/engineering/frontend/react_native/startup_firsttake/","section":"Engineerings","summary":"准备Android环境 # 1.","title":"","type":"engineering"},{"content":" Install # npm install echarts --save 概念?concept # 图表容器以及大小 # 初始化 # HTML中指定大小 \u0026lt;div id=\u0026#34;main\u0026#34; style=\u0026#34;width: 600px;height:400px;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var myChart = echarts.init(document.getElementById(\u0026#39;main\u0026#39;)); \u0026lt;/script\u0026gt; 初始化时指定大小 \u0026lt;div id=\u0026#34;main\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var myChart = echarts.init(document.getElementById(\u0026#39;main\u0026#39;), null, { width: 600, height: 400 }); \u0026lt;/script\u0026gt; 响应式改变大小 # 屏幕大小改变时,希望图表还是占相应屏幕上相应比例.\n\u0026lt;style\u0026gt; #main, html, body { width: 100%; } #main { height: 400px; } \u0026lt;/style\u0026gt; \u0026lt;div id=\u0026#34;main\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var myChart = echarts.init(document.getElementById(\u0026#39;main\u0026#39;)); window.addEventListener(\u0026#39;resize\u0026#39;, function() { myChart.resize(); }); \u0026lt;/script\u0026gt; 假设页面中存在多个标签页，每个标签页都包含一些图表。当选中一个标签页的时候，其他标签页的内容在 DOM 中被移除了。这样，当用户再选中这些标签页的时候，就会发现图表“不见”了。\n本质上，这是由于图表的容器节点被移除导致的。即使之后该节点被重新添加，图表所在的节点也已经不存在了。\n正确的做法是，在图表容器被销毁之后，调用 echartsInstance.dispose 销毁实例，在图表容器重新被添加后再次调用 echarts.init 初始化。\n样式 # 主题 # var chart = echarts.init(dom, \u0026#39;dark\u0026#39;); 其他自定义主题,下载JSON文件,并加载.\n// 假设主题名称是 \u0026#34;vintage\u0026#34; fetch(\u0026#39;theme/vintage.json\u0026#39;) .then(r =\u0026gt; r.json()) .then(theme =\u0026gt; { echarts.registerTheme(\u0026#39;vintage\u0026#39;, theme); var chart = echarts.init(dom, \u0026#39;vintage\u0026#39;); }) //若已经保存为UMD格式的js文件,直接引入 // HTML 引入 vintage.js 文件后（假设主题名称是 \u0026#34;vintage\u0026#34;） var chart = echarts.init(dom, \u0026#39;vintage\u0026#39;); // ... 调色盘 # 调色盘，可以在 option 中设置。它给定了一组颜色，图形、系列会自动从其中选择颜色。 可以设置全局的调色盘，也可以设置系列自己专属的调色盘。\noption = { // 全局调色盘。 color: [ \u0026#39;#c23531\u0026#39;, \u0026#39;#2f4554\u0026#39;, \u0026#39;#61a0a8\u0026#39;, \u0026#39;#d48265\u0026#39;, \u0026#39;#91c7ae\u0026#39;, \u0026#39;#749f83\u0026#39;, \u0026#39;#ca8622\u0026#39;, \u0026#39;#bda29a\u0026#39;, \u0026#39;#6e7074\u0026#39;, \u0026#39;#546570\u0026#39;, \u0026#39;#c4ccd3\u0026#39; ], series: [ { type: \u0026#39;bar\u0026#39;, // 此系列自己的调色盘。 color: [ \u0026#39;#dd6b66\u0026#39;, \u0026#39;#759aa0\u0026#39;, \u0026#39;#e69d87\u0026#39;, \u0026#39;#8dc1a9\u0026#39;, \u0026#39;#ea7e53\u0026#39;, \u0026#39;#eedd78\u0026#39;, \u0026#39;#73a373\u0026#39;, \u0026#39;#73b9bc\u0026#39;, \u0026#39;#7289ab\u0026#39;, \u0026#39;#91ca8c\u0026#39;, \u0026#39;#f49f42\u0026#39; ] // ... }, { type: \u0026#39;pie\u0026#39;, // 此系列自己的调色盘。 color: [ \u0026#39;#37A2DA\u0026#39;, \u0026#39;#32C5E9\u0026#39;, \u0026#39;#67E0E3\u0026#39;, \u0026#39;#9FE6B8\u0026#39;, \u0026#39;#FFDB5C\u0026#39;, \u0026#39;#ff9f7f\u0026#39;, \u0026#39;#fb7293\u0026#39;, \u0026#39;#E062AE\u0026#39;, \u0026#39;#E690D1\u0026#39;, \u0026#39;#e7bcf3\u0026#39;, \u0026#39;#9d96f5\u0026#39;, \u0026#39;#8378EA\u0026#39;, \u0026#39;#96BFFF\u0026#39; ] // ... } ] }; 直接样式 # 直接在option中设置itemStyle LineStyle areaStyle等\n高亮 # option = { series: { type: \u0026#39;scatter\u0026#39;, // 普通样式。 itemStyle: { // 点的颜色。 color: \u0026#39;red\u0026#39; }, label: { show: true, // 标签的文字。 formatter: \u0026#39;This is a normal label.\u0026#39; }, // 高亮样式。 emphasis: { itemStyle: { // 高亮时点的颜色。 color: \u0026#39;blue\u0026#39; }, label: { show: true, // 高亮时标签的文字。 formatter: \u0026#39;This is a emphasis label.\u0026#39; } } } }; 视觉映射 # VisualMap组件\n数据集 # 展示在图表上的数据\n系列series # 直接在series中放入数据\noption = { xAxis: { type: \u0026#39;category\u0026#39;, data: [\u0026#39;Matcha Latte\u0026#39;, \u0026#39;Milk Tea\u0026#39;, \u0026#39;Cheese Cocoa\u0026#39;, \u0026#39;Walnut Brownie\u0026#39;] }, yAxis: {}, series: [ { type: \u0026#39;bar\u0026#39;, name: \u0026#39;2015\u0026#39;, data: [89.3, 92.1, 94.4, 85.4] }, { type: \u0026#39;bar\u0026#39;, name: \u0026#39;2016\u0026#39;, data: [95.8, 89.4, 91.2, 76.9] }, { type: \u0026#39;bar\u0026#39;, name: \u0026#39;2017\u0026#39;, data: [97.7, 83.1, 92.5, 78.1] } ] }; 优点：可以对数据的结构定值。 缺点：需要用户进行处理，把数据划分到各项中。\n数据集dataset # 把数据单独放到一个dataset中,一个提供数据,一个提供展示,也易于对数据进行修改,数据复用等.\noption = { legend: {}, tooltip: {}, dataset: { // 提供一份数据。 source: [ [\u0026#39;product\u0026#39;, \u0026#39;2015\u0026#39;, \u0026#39;2016\u0026#39;, \u0026#39;2017\u0026#39;], [\u0026#39;Matcha Latte\u0026#39;, 43.3, 85.8, 93.7], [\u0026#39;Milk Tea\u0026#39;, 83.1, 73.4, 55.1], [\u0026#39;Cheese Cocoa\u0026#39;, 86.4, 65.2, 82.5], [\u0026#39;Walnut Brownie\u0026#39;, 72.4, 53.9, 39.1] ] }, // 声明一个 X 轴，类目轴（category）。默认情况下，类目轴对应到 dataset 第一列。 xAxis: { type: \u0026#39;category\u0026#39; }, // 声明一个 Y 轴，数值轴。 yAxis: {}, // 声明多个 bar 系列，默认情况下，每个系列会自动对应到 dataset 的每一列。 series: [{ type: \u0026#39;bar\u0026#39; }, { type: \u0026#39;bar\u0026#39; }, { type: \u0026#39;bar\u0026#39; }] }; 也可以这种对象数组形式\noption = { legend: {}, tooltip: {}, dataset: { // 用 dimensions 指定了维度的顺序。直角坐标系中，如果 X 轴 type 为 category， // 默认把第一个维度映射到 X 轴上，后面维度映射到 Y 轴上。 // 如果不指定 dimensions，也可以通过指定 series.encode // 完成映射，参见后文。 dimensions: [\u0026#39;product\u0026#39;, \u0026#39;2015\u0026#39;, \u0026#39;2016\u0026#39;, \u0026#39;2017\u0026#39;], source: [ { product: \u0026#39;Matcha Latte\u0026#39;, \u0026#39;2015\u0026#39;: 43.3, \u0026#39;2016\u0026#39;: 85.8, \u0026#39;2017\u0026#39;: 93.7 }, { product: \u0026#39;Milk Tea\u0026#39;, \u0026#39;2015\u0026#39;: 83.1, \u0026#39;2016\u0026#39;: 73.4, \u0026#39;2017\u0026#39;: 55.1 }, { product: \u0026#39;Cheese Cocoa\u0026#39;, \u0026#39;2015\u0026#39;: 86.4, \u0026#39;2016\u0026#39;: 65.2, \u0026#39;2017\u0026#39;: 82.5 }, { product: \u0026#39;Walnut Brownie\u0026#39;, \u0026#39;2015\u0026#39;: 72.4, \u0026#39;2016\u0026#39;: 53.9, \u0026#39;2017\u0026#39;: 39.1 } ] }, xAxis: { type: \u0026#39;category\u0026#39; }, yAxis: {}, series: [{ type: \u0026#39;bar\u0026#39; }, { type: \u0026#39;bar\u0026#39; }, { type: \u0026#39;bar\u0026#39; }] }; dataset映射到series # option = { legend: {}, tooltip: {}, dataset: { source: [ [\u0026#39;product\u0026#39;, \u0026#39;2012\u0026#39;, \u0026#39;2013\u0026#39;, \u0026#39;2014\u0026#39;, \u0026#39;2015\u0026#39;], [\u0026#39;Matcha Latte\u0026#39;, 41.1, 30.4, 65.1, 53.3], [\u0026#39;Milk Tea\u0026#39;, 86.5, 92.1, 85.7, 83.1], [\u0026#39;Cheese Cocoa\u0026#39;, 24.1, 67.2, 79.5, 86.4] ] }, xAxis: [ { type: \u0026#39;category\u0026#39;, gridIndex: 0 }, { type: \u0026#39;category\u0026#39;, gridIndex: 1 } ], yAxis: [{ gridIndex: 0 }, { gridIndex: 1 }], grid: [{ bottom: \u0026#39;55%\u0026#39; }, { top: \u0026#39;55%\u0026#39; }], series: [ // 这几个系列会出现在第一个直角坐标系中，每个系列对应到 dataset 的每一行。 { type: \u0026#39;bar\u0026#39;, seriesLayoutBy: \u0026#39;row\u0026#39;, xAxisIndex: 0, yAxisIndex: 0 }, { type: \u0026#39;bar\u0026#39;, seriesLayoutBy: \u0026#39;row\u0026#39;, xAxisIndex: 0, yAxisIndex: 0 }, { type: \u0026#39;bar\u0026#39;, seriesLayoutBy: \u0026#39;row\u0026#39;, xAxisIndex: 0, yAxisIndex: 0 }, // 这几个系列会出现在第二个直角坐标系中，每个系列对应到 dataset 的每一列。 { type: \u0026#39;bar\u0026#39;, seriesLayoutBy: \u0026#39;column\u0026#39;, xAxisIndex: 1, yAxisIndex: 1 }, { type: \u0026#39;bar\u0026#39;, seriesLayoutBy: \u0026#39;column\u0026#39;, xAxisIndex: 1, yAxisIndex: 1 }, { type: \u0026#39;bar\u0026#39;, seriesLayoutBy: \u0026#39;column\u0026#39;, xAxisIndex: 1, yAxisIndex: 1 }, { type: \u0026#39;bar\u0026#39;, seriesLayoutBy: \u0026#39;column\u0026#39;, xAxisIndex: 1, yAxisIndex: 1 } ] }; 数据转换transform # 把原始数据集转换为可以映射为图表的数据集\nvar option = { dataset: [ { // 这个 dataset 的 index 是 `0`。 source: [ [\u0026#39;Product\u0026#39;, \u0026#39;Sales\u0026#39;, \u0026#39;Price\u0026#39;, \u0026#39;Year\u0026#39;], [\u0026#39;Cake\u0026#39;, 123, 32, 2011], [\u0026#39;Cereal\u0026#39;, 231, 14, 2011], [\u0026#39;Tofu\u0026#39;, 235, 5, 2011], [\u0026#39;Dumpling\u0026#39;, 341, 25, 2011], [\u0026#39;Biscuit\u0026#39;, 122, 29, 2011], [\u0026#39;Cake\u0026#39;, 143, 30, 2012], [\u0026#39;Cereal\u0026#39;, 201, 19, 2012], [\u0026#39;Tofu\u0026#39;, 255, 7, 2012], [\u0026#39;Dumpling\u0026#39;, 241, 27, 2012], [\u0026#39;Biscuit\u0026#39;, 102, 34, 2012], [\u0026#39;Cake\u0026#39;, 153, 28, 2013], [\u0026#39;Cereal\u0026#39;, 181, 21, 2013], [\u0026#39;Tofu\u0026#39;, 395, 4, 2013], [\u0026#39;Dumpling\u0026#39;, 281, 31, 2013], [\u0026#39;Biscuit\u0026#39;, 92, 39, 2013], [\u0026#39;Cake\u0026#39;, 223, 29, 2014], [\u0026#39;Cereal\u0026#39;, 211, 17, 2014], [\u0026#39;Tofu\u0026#39;, 345, 3, 2014], [\u0026#39;Dumpling\u0026#39;, 211, 35, 2014], [\u0026#39;Biscuit\u0026#39;, 72, 24, 2014] ] // id: \u0026#39;a\u0026#39; }, { // 这个 dataset 的 index 是 `1`。 // 这个 `transform` 配置，表示，此 dataset 的数据，来自于此 transform 的结果。 transform: { type: \u0026#39;filter\u0026#39;, config: { dimension: \u0026#39;Year\u0026#39;, value: 2011 } } // 我们还可以设置这些可选的属性： `fromDatasetIndex` 或 `fromDatasetId`。 // 这些属性，指定了，transform 的输入，来自于哪个 dataset。例如， // `fromDatasetIndex: 0` 表示输入来自于 index 为 `0` 的 dataset 。又例如， // `fromDatasetId: \u0026#39;a\u0026#39;` 表示输入来自于 `id: \u0026#39;a\u0026#39;` 的 dataset。 // 当这些属性都不指定时，默认认为，输入来自于 index 为 `0` 的 dataset 。 }, { // 这个 dataset 的 index 是 `2`。 // 同样，这里因为 `fromDatasetIndex` 和 `fromDatasetId` 都没有被指定， // 那么输入默认来自于 index 为 `0` 的 dataset 。 transform: { // 这个类型为 \u0026#34;filter\u0026#34; 的 transform 能够遍历并筛选出满足条件的数据项。 type: \u0026#39;filter\u0026#39;, // 每个 transform 如果需要有配置参数的话，都须配置在 `config` 里。 // 在这个 \u0026#34;filter\u0026#34; transform 中，`config` 用于指定筛选条件。 // 下面这个筛选条件是：选出维度（ dimension ）\u0026#39;Year\u0026#39; 中值为 2012 的所有 // 数据项。 config: { dimension: \u0026#39;Year\u0026#39;, value: 2012 } } }, { // 这个 dataset 的 index 是 `3`。 transform: { type: \u0026#39;filter\u0026#39;, config: { dimension: \u0026#39;Year\u0026#39;, value: 2013 } } } ], series: [ { type: \u0026#39;pie\u0026#39;, radius: 50, center: [\u0026#39;25%\u0026#39;, \u0026#39;50%\u0026#39;], // 这个饼图系列，引用了 index 为 `1` 的 dataset 。也就是，引用了上述 // 2011 年那个 \u0026#34;filter\u0026#34; transform 的结果。 datasetIndex: 1 }, { type: \u0026#39;pie\u0026#39;, radius: 50, center: [\u0026#39;50%\u0026#39;, \u0026#39;50%\u0026#39;], datasetIndex: 2 }, { type: \u0026#39;pie\u0026#39;, radius: 50, center: [\u0026#39;75%\u0026#39;, \u0026#39;50%\u0026#39;], datasetIndex: 3 } ] }; 链式声明 # 一个transform得到的数据传给下一个transform进行处理\noption = { dataset: [ { source: [ // 原始数据 ] }, { // 几个 transform 被声明成 array ，他们构成了一个链， // 前一个 transform 的输出是后一个 transform 的输入。 transform: [ { type: \u0026#39;filter\u0026#39;, config: { dimension: \u0026#39;Product\u0026#39;, value: \u0026#39;Tofu\u0026#39; } }, { type: \u0026#39;sort\u0026#39;, config: { dimension: \u0026#39;Year\u0026#39;, order: \u0026#39;desc\u0026#39; } } ] } ], series: { type: \u0026#39;pie\u0026#39;, // 这个系列引用上述 transform 的结果。 datasetIndex: 1 } }; 一个transform得到多个数据 # dataset.fromTransformResult\noption = { dataset: [ { // 这个 dataset 的 index 为 `0`。 source: [ // 原始数据 ] }, { // 这个 dataset 的 index 为 `1`。 transform: { type: \u0026#39;boxplot\u0026#39; } // 这个 \u0026#34;boxplot\u0026#34; transform 生成了两个数据： // result[0]: boxplot series 所需的数据。 // result[1]: 离群点数据。 // 当其他 series 或者 dataset 引用这个 dataset 时，他们默认只能得到 // result[0] 。 // 如果想要他们得到 result[1] ，需要额外声明如下这样一个 dataset ： }, { // 这个 dataset 的 index 为 `2`。 // 这个额外的 dataset 指定了数据来源于 index 为 `1` 的 dataset。 fromDatasetIndex: 1, // 并且指定了获取 transform result[1] 。 fromTransformResult: 1 } ], xAxis: { type: \u0026#39;category\u0026#39; }, yAxis: {}, series: [ { name: \u0026#39;boxplot\u0026#39;, type: \u0026#39;boxplot\u0026#39;, // Reference the data from result[0]. // 这个 series 引用 index 为 `1` 的 dataset 。 datasetIndex: 1 }, { name: \u0026#39;outlier\u0026#39;, type: \u0026#39;scatter\u0026#39;, // 这个 series 引用 index 为 `2` 的 dataset 。 // 从而也就得到了上述的 transform result[1] （即离群点数据） datasetIndex: 2 } ] }; debug方法 # 在transform中配置print:true来进行console.log()\n数据转换filter # 关系比较操作符 # option = { dataset: [ { source: [ [\u0026#39;Product\u0026#39;, \u0026#39;Sales\u0026#39;, \u0026#39;Price\u0026#39;, \u0026#39;Year\u0026#39;], [\u0026#39;Cake\u0026#39;, 123, 32, 2011], [\u0026#39;Latte\u0026#39;, 231, 14, 2011], [\u0026#39;Tofu\u0026#39;, 235, 5, 2011], [\u0026#39;Milk Tee\u0026#39;, 341, 25, 2011], [\u0026#39;Porridge\u0026#39;, 122, 29, 2011], [\u0026#39;Cake\u0026#39;, 143, 30, 2012], [\u0026#39;Latte\u0026#39;, 201, 19, 2012], [\u0026#39;Tofu\u0026#39;, 255, 7, 2012], [\u0026#39;Milk Tee\u0026#39;, 241, 27, 2012], [\u0026#39;Porridge\u0026#39;, 102, 34, 2012], [\u0026#39;Cake\u0026#39;, 153, 28, 2013], [\u0026#39;Latte\u0026#39;, 181, 21, 2013], [\u0026#39;Tofu\u0026#39;, 395, 4, 2013], [\u0026#39;Milk Tee\u0026#39;, 281, 31, 2013], [\u0026#39;Porridge\u0026#39;, 92, 39, 2013], [\u0026#39;Cake\u0026#39;, 223, 29, 2014], [\u0026#39;Latte\u0026#39;, 211, 17, 2014], [\u0026#39;Tofu\u0026#39;, 345, 3, 2014], [\u0026#39;Milk Tee\u0026#39;, 211, 35, 2014], [\u0026#39;Porridge\u0026#39;, 72, 24, 2014] ] }, { transform: { type: \u0026#39;filter\u0026#39;, config: { dimension: \u0026#39;Year\u0026#39;, \u0026#39;=\u0026#39;: 2011 } // 这个筛选条件表示，遍历数据，筛选出维度（ dimension ） // \u0026#39;Year\u0026#39; 上值为 2011 的所有数据项。 //也可以{ dimension: \u0026#39;Price\u0026#39;, \u0026#39;\u0026gt;=\u0026#39;: 20, \u0026#39;\u0026lt;\u0026#39;: 30 } } } ], series: { type: \u0026#39;pie\u0026#39;, datasetIndex: 1 } }; 逻辑比较 # transform: { type: \u0026#39;filter\u0026#39;, config: { or: [{ and: [{ dimension: \u0026#39;Price\u0026#39;, \u0026#39;\u0026gt;=\u0026#39;: 10, \u0026#39;\u0026lt;\u0026#39;: 20 }, { dimension: \u0026#39;Sales\u0026#39;, \u0026#39;\u0026lt;\u0026#39;: 100 }, { not: { dimension: \u0026#39;Product\u0026#39;, \u0026#39;=\u0026#39;: \u0026#39;Tofu\u0026#39; } }] }, { and: [{ dimension: \u0026#39;Price\u0026#39;, \u0026#39;\u0026gt;=\u0026#39;: 10, \u0026#39;\u0026lt;\u0026#39;: 20 }, { dimension: \u0026#39;Sales\u0026#39;, \u0026#39;\u0026lt;\u0026#39;: 100 }, { not: { dimension: \u0026#39;Product\u0026#39;, \u0026#39;=\u0026#39;: \u0026#39;Cake\u0026#39; } }] }] } } 解析器parser # 可以把Data对象解析为时间戳parser: 'time' 把字符串两边空格去掉parser: 'trim' 把字符串转为数字parser: 'number'\n数据转换器sort # 对数据进行排序 多维度排序\noption = { dataset: [ { dimensions: [\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;profession\u0026#39;, \u0026#39;score\u0026#39;, \u0026#39;date\u0026#39;], source: [ [\u0026#39; Hannah Krause \u0026#39;, 41, \u0026#39;Engineer\u0026#39;, 314, \u0026#39;2011-02-12\u0026#39;], [\u0026#39;Zhao Qian \u0026#39;, 20, \u0026#39;Teacher\u0026#39;, 351, \u0026#39;2011-03-01\u0026#39;], [\u0026#39; Jasmin Krause \u0026#39;, 52, \u0026#39;Musician\u0026#39;, 287, \u0026#39;2011-02-14\u0026#39;], [\u0026#39;Li Lei\u0026#39;, 37, \u0026#39;Teacher\u0026#39;, 219, \u0026#39;2011-02-18\u0026#39;], [\u0026#39; Karle Neumann \u0026#39;, 25, \u0026#39;Engineer\u0026#39;, 253, \u0026#39;2011-04-02\u0026#39;], [\u0026#39; Adrian Groß\u0026#39;, 19, \u0026#39;Teacher\u0026#39;, null, \u0026#39;2011-01-16\u0026#39;], [\u0026#39;Mia Neumann\u0026#39;, 71, \u0026#39;Engineer\u0026#39;, 165, \u0026#39;2011-03-19\u0026#39;], [\u0026#39; Böhm Fuchs\u0026#39;, 36, \u0026#39;Musician\u0026#39;, 318, \u0026#39;2011-02-24\u0026#39;], [\u0026#39;Han Meimei \u0026#39;, 67, \u0026#39;Engineer\u0026#39;, 366, \u0026#39;2011-03-12\u0026#39;] ] }, { transform: { type: \u0026#39;sort\u0026#39;, config: [ // 对两个维度按声明的优先级分别排序。 { dimension: \u0026#39;profession\u0026#39;, order: \u0026#39;desc\u0026#39; }, { dimension: \u0026#39;score\u0026#39;, order: \u0026#39;desc\u0026#39; } ] } } ], series: { type: \u0026#39;bar\u0026#39;, datasetIndex: 1 } //... }; 外部数据转换器 # 除了上述的内置的数据转换器外，我们也可以使用外部的数据转换器。外部数据转换器能提供或自己定制更丰富的功能。下面的例子中，我们使用第三方库 ecStat 提供的数据转换器。\n// 首先要注册外部数据转换器。 echarts.registerTransform(ecStatTransform(ecStat).regression); option = { dataset: [ { source: rawData }, { transform: { // 引用注册的数据转换器。 // 注意，每个外部的数据转换器，都有名空间（如 \u0026#39;ecStat:xxx\u0026#39;，\u0026#39;ecStat\u0026#39; 是名空间）。 // 而内置数据转换器（如 \u0026#39;filter\u0026#39;, \u0026#39;sort\u0026#39;）没有名空间。 type: \u0026#39;ecStat:regression\u0026#39;, config: { // 这里是此外部数据转换器所需的参数。 method: \u0026#39;exponential\u0026#39; } } } ], xAxis: { type: \u0026#39;category\u0026#39; }, yAxis: {}, series: [ { name: \u0026#39;scatter\u0026#39;, type: \u0026#39;scatter\u0026#39;, datasetIndex: 0 }, { name: \u0026#39;regression\u0026#39;, type: \u0026#39;line\u0026#39;, symbol: \u0026#39;none\u0026#39;, datasetIndex: 1 } ] }; 坐标轴 # x轴y轴由轴线，刻度，刻度标签，轴标题组成。\n轴线 # option = { xAxis: { axisLine: { symbol: \u0026#39;arrow\u0026#39;, lineStyle: { type: \u0026#39;dashed\u0026#39; // ... } } // ... }, yAxis: { axisLine: { symbol: \u0026#39;arrow\u0026#39;, lineStyle: { type: \u0026#39;dashed\u0026#39; // ... } } } // ... }; 刻度 # option = { xAxis: { axisTick: { length: 6, lineStyle: { type: \u0026#39;dashed\u0026#39; // ... } } // ... }, yAxis: { axisTick: { length: 6, lineStyle: { type: \u0026#39;dashed\u0026#39; // ... } } } // ... }; 刻度标签 # option = { xAxis: { axisLabel: { formatter: \u0026#39;{value} kg\u0026#39;, align: \u0026#39;center\u0026#39; // ... } // ... }, yAxis: { axisLabel: { formatter: \u0026#39;{value} 元\u0026#39;, align: \u0026#39;center\u0026#39; // ... } } // ... }; 应用 # 常用图表 # 柱状图 # 把series的type设为bar\noption = { xAxis: { data: [\u0026#39;Mon\u0026#39;, \u0026#39;Tue\u0026#39;, \u0026#39;Wed\u0026#39;, \u0026#39;Thu\u0026#39;, \u0026#39;Fri\u0026#39;, \u0026#39;Sat\u0026#39;, \u0026#39;Sun\u0026#39;] }, yAxis: {}, series: [ { type: \u0026#39;bar\u0026#39;, data: [23, 24, 18, 25, 27, 28, 25] }, //多系列柱状图，每个x轴上的刻度都有两个条 { type: \u0026#39;bar\u0026#39;, data: [26, 24, 18, 22, 23, 20, 27] } ] }; 柱状图样式 # option = { xAxis: { data: [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;E\u0026#39;] }, yAxis: {}, series: [ { type: \u0026#39;bar\u0026#39;, data: [ 10, 22, 28, { value: 43, // 设置单个柱子的样式 // 单独某个柱子 itemStyle: { color: \u0026#39;#91cc75\u0026#39;, shadowColor: \u0026#39;#91cc75\u0026#39;, borderType: \u0026#39;dashed\u0026#39;, opacity: 0.5 } }, 49 ], //添加柱体背景色 并非柱体颜色 showBackground: true, backgroundStyle: { color: \u0026#39;rgba(220, 220, 220, 0.8)\u0026#39; }, //同一类中不同柱状体的距离 barGap: \u0026#39;20%\u0026#39;, //不同类中不同柱状体的距离 barCategoryGap: \u0026#39;40%\u0026#39;, //这是整体样式 itemStyle: { barBorderRadius: 5, borderWidth: 1, borderType: \u0026#39;solid\u0026#39;, borderColor: \u0026#39;#73c0de\u0026#39;, shadowColor: \u0026#39;#5470c6\u0026#39;, shadowBlur: 3 }, //每个柱条的宽度x轴上一项的长度 最大高度最小高度等等 barMaxWidth:\u0026#39;60%\u0026#39;, barWidth:\u0026#39;20%\u0026#39;, } ] }; 堆叠柱状图 # 把柱状图中的每一部分也区分开，即同样的stack显示到同一个柱中，比如下列样例，第一列的数据为10和5加起来，15。但是10和5是分开配色。\noption = { xAxis: { data: [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;E\u0026#39;] }, yAxis: {}, series: [ { data: [10, 22, 28, 43, 49], type: \u0026#39;bar\u0026#39;, stack: \u0026#39;x\u0026#39; }, { data: [5, 4, 3, 5, 10], type: \u0026#39;bar\u0026#39;, stack: \u0026#39;x\u0026#39; } ] 动态排序柱状图 # 类似三家产品的销量随着时间增长然后对比展示。\nvar data = []; for (let i = 0; i \u0026lt; 5; ++i) { data.push(Math.round(Math.random() * 200)); }//数据不断变化 option = { xAxis: { max: \u0026#39;dataMax\u0026#39; }, yAxis: { type: \u0026#39;category\u0026#39;, data: [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;E\u0026#39;], inverse: true, animationDuration: 300, animationDurationUpdate: 300, max: 2 // only the largest 3 bars will be displayed }, series: [ { realtimeSort: true, name: \u0026#39;X\u0026#39;, type: \u0026#39;bar\u0026#39;, data: data, label: { show: true, position: \u0026#39;right\u0026#39;, valueAnimation: true } } ], legend: { show: true }, animationDuration: 3000, animationDurationUpdate: 3000, animationEasing: \u0026#39;linear\u0026#39;, animationEasingUpdate: \u0026#39;linear\u0026#39; }; function update() { var data = option.series[0].data; for (var i = 0; i \u0026lt; data.length; ++i) { if (Math.random() \u0026gt; 0.9) { data[i] += Math.round(Math.random() * 2000); } else { data[i] += Math.round(Math.random() * 200); } } myChart.setOption(option); } setInterval(function() { update(); }, 3000); 阶梯瀑布图 # 类似股票价格走势，从0开始，增则网上，下一个以上一个的高度开始增减。\nvar data = [900, 345, 393, -108, -154, 135, 178, 286, -119, -361, -203]; var help = []; var positive = []; var negative = []; for (var i = 0, sum = 0; i \u0026lt; data.length; ++i) { if (data[i] \u0026gt;= 0) { positive.push(data[i]); negative.push(\u0026#39;-\u0026#39;); } else { positive.push(\u0026#39;-\u0026#39;); negative.push(-data[i]); } if (i === 0) { help.push(0); } else { sum += data[i - 1]; if (data[i] \u0026lt; 0) { help.push(sum + data[i]); } else { help.push(sum); } } } option = { title: { text: \u0026#39;Waterfall\u0026#39; }, grid: { left: \u0026#39;3%\u0026#39;, right: \u0026#39;4%\u0026#39;, bottom: \u0026#39;3%\u0026#39;, containLabel: true }, xAxis: { type: \u0026#39;category\u0026#39;, splitLine: { show: false }, data: (function() { var list = []; for (var i = 1; i \u0026lt;= 11; i++) { list.push(\u0026#39;Oct/\u0026#39; + i); } return list; })() }, yAxis: { type: \u0026#39;value\u0026#39; }, series: [ { type: \u0026#39;bar\u0026#39;, stack: \u0026#39;all\u0026#39;, itemStyle: { normal: { barBorderColor: \u0026#39;rgba(0,0,0,0)\u0026#39;, color: \u0026#39;rgba(0,0,0,0)\u0026#39; }, emphasis: { barBorderColor: \u0026#39;rgba(0,0,0,0)\u0026#39;, color: \u0026#39;rgba(0,0,0,0)\u0026#39; } }, data: help }, { name: \u0026#39;positive\u0026#39;, type: \u0026#39;bar\u0026#39;, stack: \u0026#39;all\u0026#39;, data: positive }, { name: \u0026#39;negative\u0026#39;, type: \u0026#39;bar\u0026#39;, stack: \u0026#39;all\u0026#39;, data: negative, itemStyle: { color: \u0026#39;#f33\u0026#39; } } ] }; 折线图 # 折线图主要用来展示数据项随着时间推移的趋势或变化。\n最简单的折线图 # option = { xAxis: { type: \u0026#39;category\u0026#39;, data: [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;] }, yAxis: { type: \u0026#39;value\u0026#39; }, series: [ { data: [120, 200, 150], type: \u0026#39;line\u0026#39; } ] }; 笛卡尔坐标系中的折线图 # 希望折线图在横纵坐标都是连续的，比如 从[20, 120]到[50, 200]再到[40, 50]，这是三个点。\noption = { xAxis: {}, yAxis: {}, series: [ { data: [ [20, 120], [50, 200], [40, 50] ], type: \u0026#39;line\u0026#39; } ] }; 样式 # option = { xAxis: { data: [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;E\u0026#39;] }, yAxis: {}, series: [ { data: [10, 22, 28, 23, 19], type: \u0026#39;line\u0026#39;, //使线条更平滑 smooth: true, //线条的样式，点的样式需要另外设置 itemStyle lineStyle: { normal: { color: \u0026#39;green\u0026#39;, width: 4, type: \u0026#39;dashed\u0026#39; } }, //数据点处显示数据 label: { show: true, position: \u0026#39;bottom\u0026#39;, textStyle: { fontSize: 20 } } } ] }; 空数据 # 如果希望折线图某处数据为空(非0)，那么设置\u0026rsquo;-\u0026rsquo;。\noption = { xAxis: { data: [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;E\u0026#39;] }, yAxis: {}, series: [ { data: [0, 22, \u0026#39;-\u0026#39;, 23, 19], type: \u0026#39;line\u0026#39; } ] }; 堆叠折线图 # 形式同堆叠柱状图，一般会加区域颜色，以方便识别为堆叠折线图，而不是普通两条线的折线图。\noption = { xAxis: { data: [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;E\u0026#39;] }, yAxis: {}, series: [ { data: [10, 22, 28, 43, 49], type: \u0026#39;line\u0026#39;, stack: \u0026#39;x\u0026#39;, areaStyle: {} }, { data: [5, 4, 3, 5, 10], type: \u0026#39;line\u0026#39;, stack: \u0026#39;x\u0026#39;, areaStyle: {} } ] }; 区域面积图 # 与堆叠折线图不同，每条线代表一类数据，不同线之间数据无关联，相比普通折线图，增加了区域面积展示，直观。\noption = { xAxis: { data: [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;E\u0026#39;] }, yAxis: {}, series: [ { data: [10, 22, 28, 23, 19], type: \u0026#39;line\u0026#39;, areaStyle: {} }, { data: [25, 14, 23, 35, 10], type: \u0026#39;line\u0026#39;, areaStyle: { color: \u0026#39;#ff0\u0026#39;, opacity: 0.5 } } ] }; 阶梯波形图 # 折线形状阶梯形，能直观展现变化程度。分为三种start，mid，end。\noption = { xAxis: { type: \u0026#39;category\u0026#39;, data: [\u0026#39;Mon\u0026#39;, \u0026#39;Tue\u0026#39;, \u0026#39;Wed\u0026#39;, \u0026#39;Thu\u0026#39;, \u0026#39;Fri\u0026#39;, \u0026#39;Sat\u0026#39;, \u0026#39;Sun\u0026#39;] }, yAxis: { type: \u0026#39;value\u0026#39; }, series: [ { name: \u0026#39;Step Start\u0026#39;, type: \u0026#39;line\u0026#39;, step: \u0026#39;start\u0026#39;, data: [120, 132, 101, 134, 90, 230, 210] }, { name: \u0026#39;Step Middle\u0026#39;, type: \u0026#39;line\u0026#39;, step: \u0026#39;middle\u0026#39;, data: [220, 282, 201, 234, 290, 430, 410] }, { name: \u0026#39;Step End\u0026#39;, type: \u0026#39;line\u0026#39;, step: \u0026#39;end\u0026#39;, data: [450, 432, 401, 454, 590, 530, 510] } ] }; 饼图 # 基础饼图 # option = { series: [ { type: \u0026#39;pie\u0026#39;, stillShowZeroSum: false,//值为0是否还显示在图中 label: { show: false//对应标签是否显示 }, data: [ { value: 0, name: \u0026#39;直接访问\u0026#39; }, { value: 0, name: \u0026#39;联盟广告\u0026#39; }, { value: 0, name: \u0026#39;搜索引擎\u0026#39; } ], radius: \u0026#39;30\u0026#39;, } ] }; 圆环图 # 圆环图同样可以用来表示数据占总体的比例，相比于饼图，它中间空余的部分可以用来显示一些额外的文字等信息，因而也是一种常用的图表类型。\noption = { //title: { // text: \u0026#39;圆环图的例子\u0026#39;, //left: \u0026#39;center\u0026#39;, //top: \u0026#39;center\u0026#39; //},//圆环中间部分显示的内容，如果希望根据鼠标放上的位置而显示对应类别，这个不需要 legend: { orient: \u0026#39;vertical\u0026#39;, x: \u0026#39;left\u0026#39;, data: [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;E\u0026#39;] }, series: [ { type: \u0026#39;pie\u0026#39;, radius: [\u0026#39;50%\u0026#39;, \u0026#39;70%\u0026#39;], avoidLabelOverlap: false, label: { show: false, position: \u0026#39;center\u0026#39; }, labelLine: { show: false }, emphasis: {//显示对应类别 label: { show: true, fontSize: \u0026#39;30\u0026#39;, fontWeight: \u0026#39;bold\u0026#39; } }, data: [ { value: 335, name: \u0026#39;A\u0026#39; }, { value: 310, name: \u0026#39;B\u0026#39; }, { value: 234, name: \u0026#39;C\u0026#39; }, { value: 135, name: \u0026#39;D\u0026#39; }, { value: 1548, name: \u0026#39;E\u0026#39; } ] } ] }; 南丁格尔图 # 南丁格尔图又称玫瑰图，通常用弧度相同但半径不同的扇形表示各个类目。\noption = { series: [ { type: \u0026#39;pie\u0026#39;, data: [ { value: 100, name: \u0026#39;A\u0026#39; }, { value: 200, name: \u0026#39;B\u0026#39; }, { value: 300, name: \u0026#39;C\u0026#39; }, { value: 400, name: \u0026#39;D\u0026#39; }, { value: 500, name: \u0026#39;E\u0026#39; } ], roseType: \u0026#39;area\u0026#39; } ] }; 散点图 # 点组成的图。\n简单散点图 # option = { xAxis: { data: [\u0026#39;Sun\u0026#39;, \u0026#39;Mon\u0026#39;, \u0026#39;Tue\u0026#39;, \u0026#39;Wed\u0026#39;, \u0026#39;Thu\u0026#39;, \u0026#39;Fri\u0026#39;, \u0026#39;Sat\u0026#39;] }, yAxis: {}, series: [ { type: \u0026#39;scatter\u0026#39;, data: [220, 182, 191, 234, 290, 330, 310] } ] }; 笛卡尔坐标系下的散点图 # option = { xAxis: {}, yAxis: {}, series: [ { type: \u0026#39;scatter\u0026#39;, data: [ [10, 5], [0, 8], [6, 10], [2, 12], [8, 9] ] } ] }; 样式 # option = { xAxis: { data: [\u0026#39;Sun\u0026#39;, \u0026#39;Mon\u0026#39;, \u0026#39;Tue\u0026#39;, \u0026#39;Wed\u0026#39;, \u0026#39;Thu\u0026#39;, \u0026#39;Fri\u0026#39;, \u0026#39;Sat\u0026#39;] }, yAxis: {}, series: [ { type: \u0026#39;scatter\u0026#39;, data: [220, 182, 191, 234, 290, 330, 310], symbolSize: function(value) { return value / 10; }, //symbol:\u0026#39;svg图中的path后的内容\u0026#39;, } ] }; 跨平台方案 # 数据处理 # 如果数据获取的异步的，并非直接得到，需要先初始化图表，然后获取数据后填入或先建立好图表，然后再填入。\nfunction fetchData(cb) { // 通过 setTimeout 模拟异步加载 setTimeout(function () { cb({ categories: [\u0026#39;衬衫\u0026#39;, \u0026#39;羊毛衫\u0026#39;, \u0026#39;雪纺衫\u0026#39;, \u0026#39;裤子\u0026#39;, \u0026#39;高跟鞋\u0026#39;, \u0026#39;袜子\u0026#39;], data: [5, 20, 36, 10, 10, 20] }); }, 1000); } // 初始 option 不填入数据 option = { title: { text: \u0026#39;异步数据加载示例\u0026#39; }, tooltip: {}, legend: { data: [\u0026#39;销量\u0026#39;] }, xAxis: { data: [] }, yAxis: {}, series: [ { name: \u0026#39;销量\u0026#39;, type: \u0026#39;bar\u0026#39;, data: [] } ] }; //先创建图表，然后等待数据加载后填入 fetchData(function (data) { myChart.setOption({ xAxis: { data: data.categories }, series: [ { // 根据名字对应到相应的系列 name: \u0026#39;销量\u0026#39;, data: data.data } ] }); }); 加载loading动画 # //先loading，等数据加载成功后hideloading。 myChart.showLoading(); fetchData(function (data) { myChart.hideLoading(); myChart.setOption({ xAxis: { data: data.categories }, series: [ { // 根据名字对应到相应的系列 name: \u0026#39;销量\u0026#39;, data: data.data } ] }); }); 数据动态更新 # 所有数据更新通过setOption实现，echarts会自动处理。\n标签(富文本标签) # 动画 # 交互 # 首页-》登录-》看板\n","externalUrl":null,"permalink":"/engineering/frontend/tools/echarts/","section":"Engineerings","summary":"Install # npm install echarts --save 概念?","title":"","type":"engineering"},{"content":" zod # 自定义类型认证。TypeScript是在编码时进行类型认证，那么如何判断运行后的某个数据是否符合要求呢？比如文本框是否输入了合适的数据。那么就有这个zod的包了。\n","externalUrl":null,"permalink":"/engineering/frontend/tools/packages/","section":"Engineerings","summary":"zod # 自定义类型认证。TypeScript是在编码时进行类型认证，那么如何判断运行后的某个数据是否符合要求呢？比如文本框是否输入了合适的数据。那么就有这个zod的包了。","title":"","type":"engineering"},{"content":" install # npm install -D tailwindcss npx tailwindcss init then\n/** tailwind.config.js **/ /** @type {import(\u0026#39;tailwindcss\u0026#39;).Config} */ module.exports = { content: [\u0026#34;./src/**/*.{html,js}\u0026#34;], theme: { extend: {}, }, plugins: [], } ","externalUrl":null,"permalink":"/engineering/frontend/tools/tailwindcss/","section":"Engineerings","summary":"install # npm install -D tailwindcss npx tailwindcss init then","title":"","type":"engineering"},{"content":"","externalUrl":null,"permalink":"/engineering/frontend/vue/vue-router/","section":"Engineerings","summary":"","title":"","type":"engineering"},{"content":"","externalUrl":null,"permalink":"/engineering/frontend/vue/vue-vuex/","section":"Engineerings","summary":"","title":"","type":"engineering"},{"content":" 简介以及特点 # IndexedDB、Cookie、localStorage和sessionStorage是客户端存储解决方案，它们各自具有不同的特点和适用场景：\nCookie的特点： # 自动发送：每个HTTP请求都会自动携带同源的Cookie，因此它们对服务器也是可见的。 大小限制：一般单个Cookie保存的数据不超过4KB。 生命周期：可以设置过期时间，或者为会话期Cookie，在浏览器关闭时清除。 用途：常用于存储会话标识（如用户登录信息）、个人偏好等。 安全性：可以通过设置Secure、HttpOnly和SameSite属性来提高安全性。 localStorage的特点： # 存储容量：通常比Cookie大，根据不同浏览器，可以达到5MB甚至更多。 生命周期：数据在浏览器关闭后依然存在，直到主动清除。 访问性：仅在客户端可用，不会随HTTP请求发送到服务器。 同源限制：遵循同源策略，只能被相同源的页面访问。 sessionStorage的特点： # 存储容量：与localStorage相似，具有较大的存储空间。 生命周期：数据在页面会话期间有效，当浏览器窗口或标签关闭时数据被清除。 访问性：与localStorage相同，仅在客户端可用，且遵循同源策略。 IndexedDB的特长： # 大量数据存储：可以存储大量结构化数据，包括二进制数据，容量远大于localStorage和sessionStorage。 异步操作：所有数据库操作都是异步的，不会阻塞UI线程，提高性能。 事务支持：支持事务，确保数据操作的原子性，一致性，隔离性和持久性（ACID属性）。 索引和搜索：可以创建索引，优化查询性能，高效搜索大量数据。 复杂数据类型：可以存储复杂数据类型，如对象和数组。 离线应用：适合构建离线Web应用，即使没有网络连接也能访问数据。 浏览器支持：现代浏览器广泛支持IndexedDB，但IE旧版本不支持或支持不完整。 IndexedDB的特长总结： # IndexedDB的主要优势在于其能够存储大量数据、异步操作不阻塞UI、支持事务和复杂的查询，以及对二进制数据的支持。这使得IndexedDB非常适合需要处理大量数据、构建复杂应用或离线应用的场景。相比之下，localStorage和sessionStorage更适合存储少量数据，而Cookie则适用于需要在客户端和服务器之间共享少量数据的情况。\n使用场景 # 所有的场景都基于客户端需要存储大量数据的前提下：\n数据可视化等界面，大量数据，每次请求会消耗很大性能。 即时聊天工具，大量消息需要存在本地。 其它存储方式容量不满足时，不得已使用IndexedDB 重要概念 # 数据库（Database）：\nIndexedDB中的数据库是数据的容器，有版本的概念。 对象存储（Object Store）：\n类似于关系数据库中的表，用于存储记录（数据行）。 索引（Index）：\n为对象存储中的属性创建索引，优化查询性能。 事务（Transaction）：\n数据库操作在事务中执行，确保数据的一致性和完整性。 键（Key）：\n每个记录都有一个唯一的键，用于索引和检索数据。 键范围（Key Range）：\n用于定义查询范围的对象。 游标（Cursor）：\n用于遍历对象存储中的记录。 请求（Request）：\n用于执行数据库操作，如读取、写入等。 响应（Response）：\n请求完成后的结果或错误信息。 如何使用 # 打开数据库：\n使用indexedDB.open()方法打开或创建数据库。 const request = indexedDB.open(\u0026#39;myDatabase\u0026#39;, 1); 处理数据库升级：\n在onupgradeneeded事件中创建或修改对象存储和索引。 request.onupgradeneeded = (event) =\u0026gt; { const db = event.target.result; if (!db.objectStoreNames.contains(\u0026#39;storeName\u0026#39;)) { db.createObjectStore(\u0026#39;storeName\u0026#39;, {keyPath: \u0026#39;id\u0026#39;}); } }; 创建事务和操作数据库：\n事务是执行数据库操作的单元。 const transaction = db.transaction([\u0026#39;storeName\u0026#39;], \u0026#39;readwrite\u0026#39;); const store = transaction.objectStore(\u0026#39;storeName\u0026#39;); 添加数据：\n使用add()方法添加新记录。 const request = store.add({id: 1, data: \u0026#39;My data\u0026#39;}); request.onsuccess = () =\u0026gt; console.log(\u0026#39;Data added\u0026#39;); 读取数据：\n使用get()方法读取记录。 const request = store.get(1); request.onsuccess = (event) =\u0026gt; console.log(event.target.result); 删除数据：\n使用delete()方法删除记录。 const request = store.delete(1); request.onsuccess = () =\u0026gt; console.log(\u0026#39;Data deleted\u0026#39;); 更新数据：\n使用put()方法更新记录。 const request = store.put({id: 1, data: \u0026#39;Updated data\u0026#39;}); request.onsuccess = () =\u0026gt; console.log(\u0026#39;Data updated\u0026#39;); 使用游标遍历数据：\n打开游标并遍历对象存储中的所有记录。 const request = store.openCursor(); request.onsuccess = (event) =\u0026gt; { const cursor = event.target.result; if (cursor) { console.log(cursor.value); cursor.continue(); } }; 监听事务和数据库事件：\n处理事务完成或错误。 transaction.oncomplete = () =\u0026gt; console.log(\u0026#39;Transaction completed\u0026#39;); transaction.onerror = () =\u0026gt; console.error(\u0026#39;Transaction error\u0026#39;); 关闭数据库连接：\n操作完成后关闭数据库。 db.close(); 错误处理：\n妥善处理IndexedDB操作中可能出现的错误。 使用IndexedDB时，要记住它是异步的，并且需要在事务中进行操作。通过监听事件如onsuccess、onerror、onupgradeneeded等来处理数据库的打开、升级和操作成功或失败的情况。此外，由于IndexedDB遵循同源策略，它只能被创建它的站点访问。通过上述步骤，你可以在Web应用中使用IndexedDB进行客户端存储。\n","externalUrl":null,"permalink":"/engineering/full-stack/database/indexdb/indexdb/","section":"Engineerings","summary":"简介以及特点 # IndexedDB、Cookie、localStorage和sessionStorage是客户端存储解决方案，它们各自具有不同的特点和适用场景：","title":"","type":"engineering"},{"content":"","externalUrl":null,"permalink":"/engineering/full-stack/database/postgres/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","section":"Engineerings","summary":"","title":"","type":"engineering"},{"content":"前端如何获取数据?\najax # 异步通信：Ajax 允许浏览器在不影响现有页面显示的情况下，与服务器进行通信。这意味着用户界面可以继续响应用户操作，而不会因为等待服务器响应而冻结。\nJavaScript 驱动：Ajax 请求完全由 JavaScript 控制，这使得可以在用户执行特定操作（如点击按钮）时触发。\n数据交换：Ajax 可以发送和接收多种格式的数据，虽然名字中有 XML，但它也可以处理 JSON、HTML 以及纯文本格式。\n局部更新：通过 Ajax，可以仅更新页面的一部分，而不是重新加载整个页面，这提高了用户体验并减少了服务器负载。\n//新建核心对象 var xhr = new XMLHttpRequest(); //`method`：请求类型，如 “GET”, “POST” 等。 //`url`：请求发送的目标 URL。 //`async`：表示请求是否异步，通常为 `true`。 //xhr.open(method,url,async) xhr.open(\u0026#34;GET\u0026#34;, \u0026#34;http://localhost:3000/api/data\u0026#34;, true); //设置请求头（可选） xhr.setRequestHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;); //`readyState` 为 4 表示请求完成，`status` 为 200 表示服务器响应成功。 xhr.onreadystatechange = function () { if (xhr.readyState === 4 \u0026amp;\u0026amp; xhr.status === 200) { // 请求完成，处理响应数据 document.getElementById(\u0026#34;data\u0026#34;).innerHTML = xhr.responseText; } }; xhr.send(); // 发送请求 GET请求一般不需要send参数 // xhr.send(data); // 发送请求 POST请求需要send参数 axios # Axios 是一个基于 Promise 的 HTTP 客户端，用于浏览器和 node.js 环境。它是一个流行的第三方库，提供了一种更简洁和易于使用的方式来发送 HTTP 请求。以下是 Axios 的一些关键特性和如何使用它的示例。\n基于 Promise：Axios 使用 Promise API，使得异步 HTTP 请求的处理更加方便和简洁。 请求和响应拦截器：可以在请求或响应被 then 或 catch 处理之前拦截它们。 转换请求和响应数据：可以转换请求数据和响应数据，使其在发送或接收之前符合特定的格式。 取消请求：可以取消正在进行的 HTTP 请求。 自动转换 JSON 数据：默认情况下，Axios 会自动将接收到的 JSON 数据转换为 JavaScript 对象。 客户端支持：支持浏览器和 node.js 环境。 npm install axios 基本使用实例\nconst axios = require(\u0026#34;axios\u0026#34;); //GET请求 axios .get(\u0026#34;http://localhost:3000/api/data\u0026#34;) //请求data数据 .then((res) =\u0026gt; console.log(res.data)) //请求成功后怎么做 .catch((err) =\u0026gt; console.log(err)); //请求失败后怎么做 //POST请求 axios .post(\u0026#34;http://localhost:3000/api/data\u0026#34;, { name: \u0026#34;张三\u0026#34; }) //发送data数据 .then((res) =\u0026gt; console.log(res.data)) //发送data数据成功后怎么做; .catch((err) =\u0026gt; console.log(err)); //发送data数据失败后怎么做; //封装请求数据函数 async function getData() { try { const res = await axios.get(\u0026#34;http://localhost:3000/api/data\u0026#34;); console.log(res.data); } catch (err) { if (err.message === \u0026#34;User is not authenticated\u0026#34;) { // 处理未授权的情况，例如重定向到登录页面 console.error(\u0026#34;Access denied: User is not authenticated\u0026#34;); } console.log(err); } } //封装发送数据函数 async function postData(postData) { try { const res = await axios.post(\u0026#34;http://localhost:3000/api/data\u0026#34;, postData); console.log(res.data); } catch (err) { console.log(err); } } // 假设有一个函数用于检查用户是否已授权 function isAuthenticated() { // 这里应该包含你的认证逻辑，例如检查本地存储、cookie 或状态管理库中的 token // 返回 true 如果用户已授权，否则返回 false const token = localStorage.getItem(\u0026#34;userToken\u0026#34;); return token \u0026amp;\u0026amp; token !== \u0026#34;\u0026#34;; } // 添加请求拦截器 axios.interceptors.request.use( function (config) { // 在发送请求之前做些什么 // if (!isAuthenticated()) { // return Promise.reject(new Error(\u0026#34;User is not authenticated\u0026#34;)); // } return config; }, function (error) { // 对请求错误做些什么 return Promise.reject(error); } ); // 添加响应拦截器 axios.interceptors.response.use( function (response) { // 对响应数据做点什么 return response; }, function (error) { // 对响应错误做点什么 return Promise.reject(error); } ); fetch # fetch 是现代浏览器提供的一个用于与服务器交换数据的 API，它提供了一种更简洁和一致的接口来处理 HTTP 请求。fetch API 返回一个 Promise，一旦请求完成，这个 Promise 就会解决，并提供一个 Response 对象，它包含了服务器响应的信息。\n//GET数据 // fetch(\u0026#34;http://localhost:3000/api/data\u0026#34;) // .then((res) =\u0026gt; res.json()) // .then((data) =\u0026gt; console.log(data)) // .catch((err) =\u0026gt; console.log(err)); //POST数据 // fetch(\u0026#34;http://localhost:3000/api/data\u0026#34;, { // method: \u0026#34;POST\u0026#34;, // body: JSON.stringify({ name: \u0026#34;John\u0026#34;, age: 30 }), // }).then((res) =\u0026gt; res.json()); export async function fetchData() { const res = await fetch(\u0026#34;http://localhost:3000/api/data\u0026#34;); const data = await res.json(); console.log(\u0026#34;res\u0026#34;, res); console.log(\u0026#34;data\u0026#34;, data); document.getElementById(\u0026#34;data\u0026#34;).innerHTML = data.name; return data; } export async function postData() { fetch(\u0026#34;http://localhost:3000/api/data\u0026#34;, { method: \u0026#34;POST\u0026#34;, body: JSON.stringify({ name: \u0026#34;John\u0026#34;, age: 30 }), }).then((res) =\u0026gt; res.json()); console.log(\u0026#34;Data posted successfully\u0026#34;); } ","externalUrl":null,"permalink":"/engineering/full-stack/javascript/howfrontgetdata/","section":"Engineerings","summary":"前端如何获取数据?","title":"","type":"engineering"},{"content":"nextjs分为app router和文件系统路由\nJavaScript中为什么需要异步函数async await？\n因为对于一些函数由于执行需要一段时间（操作是异步的，比如网络请求，在先执行后会返回一个未解析的对象，然后等待网络请求的反应，反应结束后才返回这个函数预期的结果），如果不添加异步操作，会导致获取未解析对象后就立马向下执行。\n路由 # 默认情况下app文件夹下的组件是服务端组件，\n文件夹路径下有page.js才可以被访问，否则这个页面不显示。\n定义路由 链接 错误处理 重定向 导航\n数据获取 # 服务端 fetch # 支持缓存、重新验证数据\nasync function getData() { const res = await fetch(\u0026#39;https://api.example.com/...\u0026#39;) // The return value is *not* serialized // You can return Date, Map, Set, etc. if (!res.ok) { // This will activate the closest `error.js` Error Boundary throw new Error(\u0026#39;Failed to fetch data\u0026#39;) } return res.json() } export default async function Page() { const data = await getData() return \u0026lt;main\u0026gt;\u0026lt;/main\u0026gt; } 使用第三方库在服务器上获取数据 # import { cache } from \u0026#39;react\u0026#39; export const getItem = cache(async (id: string) =\u0026gt; { const item = await db.item.findUnique({ id }) return item }) 使用路由处理器在客户端上获取数据 # 如果需要在客户端组件中获取数据，可以从客户端调用路由处理程序。路由处理程序在服务器上执行并将数据返回给客户端。当您不想向客户端公开敏感信息（例如 API 令牌）时，这很有用。\n使用第三方库在客户端上获取数据 # 您也可以使用第三方库（如SWR或TanStack Query）在客户端上获取数据。这些库提供自己的 API，用于记忆请求、缓存、重新验证和更改数据。\n渲染 # 将编写的代码转换为页面显示内容。\n应用程序代码在其中执行的环境：服务器和客户端 用户访问程序或与程序交互时启动的请求-响应生命周期 分隔服务器代码和客户端代码的网络边界\n曾经开发客户端和服务端的人员必须使用不同的代码，但是在React项目中，可以都使用JavaScript。\n混合应用程序\n在这些环境中工作时，将应用程序中的代码流视为单向流会很有帮助。换言之，在响应期间，应用程序代码沿一个方向流动：从服务器到客户端。\n如果需要从客户端访问服务器，请向服务器发送新请求，而不是重复使用相同的请求。这样可以更轻松地了解渲染组件的位置以及放置网络边界的位置。\n在实践中，此模型鼓励开发人员首先考虑他们想要在服务器上执行的内容，然后再将结果发送到客户端并使应用程序具有交互性。\n服务器组件 # 服务器渲染策略\n静态 # 使用静态渲染时，路由在构建时渲染，或在数据重新验证后在后台渲染。结果将被缓存，并可以推送到内容分发网络 （CDN）。此优化允许您在用户和服务器请求之间共享渲染工作的结果。\n动态 # 对不同用户有个性化需求，\n客户端组件 # 文件系统路由，即页面路径是根据文件夹目录pages/决定的\n动态路由的页面 # 如果有pages/posts/[id].js的文件，那么可以通过posts/1、posts/2来访问路径。\n预渲染 # 静态生成 # 构建时就已经生成HTML文件了，比如在项目中直接build得到的文件。\n静态生成得到的页面，可以分为带有或不带有数据。\n不带有数据的，直接生成！\n带有数据的，分为内容取决于外部数据或页面路径取决于外部数据。\n页面内容取决于外部数据 使用 getStaticProps // TODO: 需要获取 `posts`（通过调用 API ） // 在此页面被预渲染之前 function Blog({ posts }) { return ( \u0026lt;ul\u0026gt; {posts.map((post) =\u0026gt; ( \u0026lt;li\u0026gt;{post.title}\u0026lt;/li\u0026gt; ))} \u0026lt;/ul\u0026gt; ) } // 此函数在构建时被调用 export async function getStaticProps() { // 调用外部 API 获取博文列表 const res = await fetch(\u0026#39;https://.../posts\u0026#39;) const posts = await res.json() // 通过返回 { props: { posts } } 对象，Blog 组件 // 在构建时将接收到 `posts` 参数 return { props: { posts, }, } } export default Blog 页面路径取决于外部数据 使用 getStaticPaths （通常还要同时使用 getStaticProps） Next.js 允许你创建具有 动态路由 的页面。例如，你可以创建一个名为 pages/posts/[id].js 的文件用以展示以 id 标识的单篇博客文章。当你访问 posts/1 路径时将展示 id: 1 的博客文章。 function Post({post}){ //renders post } // 此函数在构建时被调用 export async function getStaticPaths() { // 调用外部 API 获取博文列表 const res = await fetch(\u0026#39;https://.../posts\u0026#39;) const posts = await res.json() // 据博文列表生成所有需要预渲染的路径 const paths = posts.map((post) =\u0026gt; ({ params: { id: post.id }, })) // We\u0026#39;ll pre-render only these paths at build time. // { fallback: false } means other routes should 404. return { paths, fallback: false } } // 在构建时也会被调用 export async function getStaticProps({ params }) { // params 包含此片博文的 `id` 信息。 // 如果路由是 /posts/1，那么 params.id 就是 1 const res = await fetch(`https://.../posts/${params.id}`) const post = await res.json() // 通过 props 参数向页面传递博文的数据 return { props: { post } } } export default Post 什么时候使用静态生成？ # 我们建议您尽可能使用 静态生成 （带有或不带数据），因为你的所有 page（页面）都可以只构建一次并托管到 CDN 上，这比让服务器根据每个页面请求来渲染页面快得多。\n您应该问问自己：“我可以在用户请求之前预先渲染此页面吗？” 如果答案是肯定的，则应选择“静态生成”。\n服务器端渲染 SSR或动态渲染 # 如果页面使用的是服务端渲染，那么每次页面请求都会重新生成HTML。\n要对 page（页面）使用服务器端渲染，你需要 export 一个名为 getServerSideProps 的 async 函数。服务器将在每次页面请求时调用此函数。\n例如，假设你的某个页面需要预渲染频繁更新的数据（从外部 API 获取）。你就可以编写 getServerSideProps 获取该数据并将其传递给 Page ，如下所示：\nfunction Page({ data }) { // Render data... } // This gets called on every request export async function getServerSideProps() { // Fetch data from external API const res = await fetch(`https://.../data`) const data = await res.json() // Pass data to the page via props return { props: { data } } } export default Page 更推荐静态生成\n获取数据 # 静态生成 getStaticProps # export async function getStaticProps(context) { const res = await fetch(`https://.../data`) const data = await res.json() if (!data) { return { notFound: true, } } return { props: { data }, // will be passed to the page component as props } } 身份验证 # 设置 参照VSCode 悬浮于页面 首导航栏 选项内容 设置页面\n","externalUrl":null,"permalink":"/engineering/full-stack/nextjs/0001/","section":"Engineerings","summary":"nextjs分为app router和文件系统路由","title":"","type":"engineering"},{"content":"关于React的框架 NextJS\n","externalUrl":null,"permalink":"/engineering/full-stack/nextjs/readme/","section":"Engineerings","summary":"关于React的框架 NextJS","title":"","type":"engineering"},{"content":"为什么React? 原生JavaScript操作DOM繁琐 操作实DOM 浏览器会经常重排 不够模块化 组件化 代码复用率低 虚拟DOM 虚拟DOM属性少 更轻、最终会被React转换为真实DOM\n组件三大属性 props refs state\nhooks可以让函数式组件也可以使用state\nstate 组件的记忆 # 组件被称为\u0026quot;状态机\u0026quot;, 通过更新组件的state来更新对应的页面显示(重新渲染组件) 你将从 useState 中获得两样东西：当前的 state（count），以及用于更新它的函数（setCount）。你可以给它们起任何名字，但按照惯例会像 [something, setSomething] 这样为它们命名。 props # 适用于父传子\nContext # 组件间的通信，无需重复写多个props\n生命周期 # 注意 # 虚拟DOM中的key的作用 # 索引值当成key，逆序添加会出现问题\n纯函数写法 # 有些 JavaScript 函数是 纯粹 的。纯函数的基本定义：\n只负责自己的任务。 它不会更改在该函数调用前就已存在的对象或变量 需要的变量只在函数内调用。 输入相同，输出也相同。 在输入相同的情况下，对纯函数来说应总是返回相同的结果。 严格遵循纯函数的定义编写组件，可以让代码库体量增长时，避免一些令人困惑的错误和不可预测的行为。下面是一个非纯函数组件的示例：\n渲染列表 # filter()筛选、map()把数组转换为组件\nconst chemists = people.filter(person =\u0026gt; person.profession === \u0026#39;化学家\u0026#39; ); 尽量写纯函数 # 对于相同的输入，返回的值不会改变\n","externalUrl":null,"permalink":"/engineering/full-stack/react/0001/","section":"Engineerings","summary":"为什么React? 原生JavaScript操作DOM繁琐 操作实DOM 浏览器会经常重排 不够模块化 组件化 代码复用率低 虚拟DOM 虚拟DOM属性少 更轻、最终会被React转换为真实DOM","title":"","type":"engineering"},{"content":"Prisma ORM对象关系映射 NextAuth\n","externalUrl":null,"permalink":"/engineering/full-stack/react/0002/","section":"Engineerings","summary":"Prisma ORM对象关系映射 NextAuth","title":"","type":"engineering"},{"content":" install # npm install @supabase/supabase-js 初始化\nimport { createClient } from \u0026#39;@supabase/supabase-js\u0026#39; // Create a single supabase client for interacting with your database const supabase = createClient(\u0026#39;https://xyzcompany.supabase.co\u0026#39;, \u0026#39;public-anon-key\u0026#39;) 同样支持ts\n数据库操作 # 获取 fetch data # const {data,error} = await supabase.from(\u0026#39;countries\u0026#39;).select() //从表中from 插入 insert data # const { error } = await supabase .from(\u0026#39;countries\u0026#39;) .insert({ id: 1, name: \u0026#39;Denmark\u0026#39; }) 更新 update data # const { error } = await supabase .from(\u0026#39;countries\u0026#39;) .update({ name: \u0026#39;Australia\u0026#39; }) .eq(\u0026#39;id\u0026#39;, 1) 更新插入 upsert data # const { data, error } = await supabase .from(\u0026#39;countries\u0026#39;) .upsert({ id: 1, name: \u0026#39;Albania\u0026#39; }) .select() //插入数据后并返回这个数据 删除 delete data # const response = await supabase .from(\u0026#39;countries\u0026#39;) .delete() .eq(\u0026#39;id\u0026#39;, 1) 调用 call a postgres function # const { data, error } = await supabase.rpc(\u0026#39;hello_world\u0026#39;) 使用 using filter # const { data, error } = await supabase .from(\u0026#39;cities\u0026#39;) .select(\u0026#39;name, country_id\u0026#39;) .eq(\u0026#39;name\u0026#39;, \u0026#39;The Shire\u0026#39;) // Correct //列中等于The Shire的值 filters # modifiers # const { data, error } = await supabase .from(\u0026#39;countries\u0026#39;) .upsert({ id: 1, name: \u0026#39;Algeria\u0026#39; }) .select() //插入结果后 select 返回结果给data 认证Auth # supabase也有认证功能\nimport { createClient } from \u0026#39;@supabase/supabase-js\u0026#39; const supabase = createClient(supabase_url, anon_key) //服务器端 import { createClient } from \u0026#39;@supabase/supabase-js\u0026#39; const supabase = createClient(supabase_url, anon_key, { auth: { autoRefreshToken: false, persistSession: false, detectSessionInUrl: false } }) 创建新用户 # const { data, error } = await supabase.auth.signUp({ phone: \u0026#39;123456789\u0026#39;, password: \u0026#39;example-password\u0026#39;, options: { channel: \u0026#39;sms\u0026#39; } }) 倾听身份验证事件 # const { data } = supabase.auth.onAuthStateChange((event, session) =\u0026gt; { console.log(event, session) if (event === \u0026#39;INITIAL_SESSION\u0026#39;) { // handle initial session } else if (event === \u0026#39;SIGNED_IN\u0026#39;) { // handle sign in event } else if (event === \u0026#39;SIGNED_OUT\u0026#39;) { // handle sign out event } else if (event === \u0026#39;PASSWORD_RECOVERY\u0026#39;) { // handle password recovery event } else if (event === \u0026#39;TOKEN_REFRESHED\u0026#39;) { // handle token refreshed event } else if (event === \u0026#39;USER_UPDATED\u0026#39;) { // handle user updated event } }) // call unsubscribe to remove the callback data.subscription.unsubscribe() 创建匿名用户 # const { data, error } = await supabase.auth.signInAnonymously({ options: { captchaToken } }); 如此云云~~\nSupabase Javascript 客户端 - 简介 \u0026mdash; Supabase Javascript Client - Introduction\n支持EDGE Function # const { data, error } = await supabase.functions.invoke(\u0026#39;hello\u0026#39;, { headers: { \u0026#34;my-custom-header\u0026#34;: \u0026#39;my-custom-header-value\u0026#39; }, method: \u0026#39;GET\u0026#39; }) 实时 Realtime # 监听数据库中的表项更改。 当我们把一张表的Realtime选项开启后，这张表数据的增删改操作，都会产生消息，并且推送到每个订阅了这个频道消息的客户端上。\nimport { RealtimeClient } from \u0026#39;@supabase/realtime-js\u0026#39; const client = new RealtimeClient(REALTIME_URL, { params: { apikey: API_KEY }, }) const channel = client.channel(\u0026#39;test-channel\u0026#39;, {}) channel.subscribe((status, err) =\u0026gt; { if (status === \u0026#39;SUBSCRIBED\u0026#39;) { console.log(\u0026#39;Connected!\u0026#39;) } if (status === \u0026#39;CHANNEL_ERROR\u0026#39;) { console.log(`There was an error subscribing to channel: ${err.message}`) } if (status === \u0026#39;TIMED_OUT\u0026#39;) { console.log(\u0026#39;Realtime server did not respond in time.\u0026#39;) } if (status === \u0026#39;CLOSED\u0026#39;) { console.log(\u0026#39;Realtime channel was unexpectedly closed.\u0026#39;) } }) 存储桶 # Supabase的存储桶（Storage Bucket）是Supabase平台提供的一项服务，它允许用户上传、存储和管理文件，类似于Amazon S3或Google Cloud Storage。以下是Supabase存储桶的主要功能和用途：\n创建存储桶 # const { data, error } = await supabase .storage .createBucket(\u0026#39;avatars\u0026#39;, { public: false, allowedMimeTypes: [\u0026#39;image/png\u0026#39;], fileSizeLimit: 1024 }) 检索存储桶 # const { data, error } = await supabase .storage .getBucket(\u0026#39;avatars\u0026#39;) 列出所有存储桶 # const { data, error } = await supabase .storage .listBuckets() 更新存储桶 # const { data, error } = await supabase .storage .updateBucket(\u0026#39;avatars\u0026#39;, { public: false, allowedMimeTypes: [\u0026#39;image/png\u0026#39;], fileSizeLimit: 1024 }) 删除存储桶 # const { data, error } = await supabase .storage .deleteBucket(\u0026#39;avatars\u0026#39;) 清空存储桶 # const { data, error } = await supabase .storage .emptyBucket(\u0026#39;avatars\u0026#39;) 签名URL # 类似网盘分享链接，这个链接可以下载可以上传\nconst { data, error } = await supabase .storage .from(\u0026#39;avatars\u0026#39;) .createSignedUrl(\u0026#39;folder/avatar1.png\u0026#39;, 60) 测试supabase存储桶功能 测试主题变换 设置页面 侧边文件栏如何实现\n富文本编译器tiptap\n前后端交接\n","externalUrl":null,"permalink":"/engineering/full-stack/supabase/intro/","section":"Engineerings","summary":"install # npm install @supabase/supabase-js 初始化","title":"","type":"engineering"},{"content":"文件实时保存 打开文档就获取信息 使用二进制传输，如果我修改了\nhttps://cloud.tencent.com/developer/article/2355422\n","externalUrl":null,"permalink":"/engineering/issues/documentautosave/","section":"Engineerings","summary":"文件实时保存 打开文档就获取信息 使用二进制传输，如果我修改了","title":"","type":"engineering"},{"content":" 两个进程函数 # fork() 函数 在 LINUX 系统创建一个新进程的唯一方法是使用fork()函数.\n函数说明 fork()函数用于在一个已知进程中创建一个新进程,新进程被称为子进程,原进程为父进程.自进程继承了父进程整个进程的地址空间,包括进程的上下文、代码段、进程堆栈、内存信息、打开的文件描述符、符号控制设定、进程优先级、进程组号、当前工作目录、根目录、资源限制和控制终端等.子进程相比而言独有的是进程号,资源使用和计时器等. 父进程的fork()函数返回的是创建的子进程的pid值,而子进程执行的fork()函数返回的值是0,可以通过这个来区分子进程与父进程. fork()函数复制了父进程的大部分内容,使得系统开销很大,而且执行速度也不快. 所需头文件 #include\u0026lt;sys/types.h\u0026gt;/*提供类型pid*/#include\u0026lt;unistd.h\u0026gt; ��数原型 | id_t fork(void) | ��数返回值 | :子进程子进程PID(大于0的整数:父进程-1:出错| exec() 函数 按照我的理解是,终止当前进程的所有内容,运行选择的进程的内容\n函数说明 ","externalUrl":null,"permalink":"/engineering/linux/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B/","section":"Engineerings","summary":"两个进程函数 # fork() 函数 在 LINUX 系统创建一个新进程的唯一方法是使用fork()函数.","title":"","type":"engineering"},{"content":" 逻辑流与并发流 # 并发 # 逻辑控制流 # 并发流及相关概念 # 并发与并行 # 进程基本概念 # 进程概念、结构与描述 # 什么是进程 # 进程结构 # 进程属性(保存在PCB中) # 进程描述信息 进程控制信息 进程资源信息\n进程状态 就绪 阻塞 运行 进程 双向链表+树形结构 树形结构为父子关系，父节点为父进程，子节点位子进程，用p_pptr 进程实例\n操作进程工具 # ps命令查看进程信息 $ps -ef $pfs-ef|bash here ps -u ps l显示当前用户拥有的进程信息 kill 终止进程 命令后加 \u0026amp; 使进程在后台进行 get_pid\n","externalUrl":null,"permalink":"/engineering/linux/linxu%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B/","section":"Engineerings","summary":"逻辑流与并发流 # 并发 # 逻辑控制流 # 并发流及相关概念 # 并发与并行 # 进程基本概念 # 进程概念、结构与描述 # 什么是进程 # 进程结构 # 进程属性(保存在PCB中) # 进程描述信息 进程控制信息 进程资源信息","title":"","type":"engineering"},{"content":" 常用指令 # vi编辑器 # 命令行指令 vi filename 编辑器内部命令行指令 :set nu 显示行号 :w 保存 :w newfilename 另存为 :/word\t查询单词word :/word\tn N\t(n 向下寻找,N 向上寻找)\ti\t插入 y\t复制 p\t粘贴 d\t删除 w\t切换到下一个单词 :wq\t保存并退出 文件管理指令 # 删除操作 # 删除文件\n单个文件 rm -f 文件名 多个文件 rm -f *文件关键字* 重命名文件/文件夹 mv (当前名称) (更改后名称) 使用gcc编译c程序 # 编写一个c程序 program.c 通过gcc program.c指令编译生成a.out文件 通过./a.out进行执行这个程序 后台执行 就在后边加\u0026amp;\n管道通信 # 管道由Linux系统提供的pipe()函数创建，该函数原型为：\n#include\u0026lt;unistd.h\u0026gt; int pipe(filedes[2]); pipe() 函数用于在内核中创建一个通道,一端用于读取数据,另一端用于写入数据.创建完成后,会得到两个文件描述符,用于读取和写入\n管道系统调用函数:\nwirte(); read(); close(); open(); 线程编程 # 进程间通信 # Linux提供了管道通信,消息队列,信号量,套接字通信(网络通信)\n为什么需要进程间通信? # 数据传输 管道通信 # 管道通信是单向的,先进先出的.将一个进程的输出与另一个进程的输出连接到一起.在一个进程(写进程)的尾部写入数据,另一个进程(读进程)的头部读出数据.\n数据被进程读出后,将从管道中删除,其他进程不能在读取数据/管道提供了简单的流控制机制,进程试图读取空管道时,进程将堵塞.\n无名管道\n创建 无名管道由创建 管道关闭 关闭管道只需将这两个文件描述符关闭即可.也可以使用普通的close函数逐个关闭. 使用特点 只能用于具有亲缘关系的进程间通信(如父子进程) 工作方式为半双工 使用功能 常用于 注意事项 可以通过打开两个管道来创建一个双向的管道.但需要在子进程中正确地设置文件描述符. 必须在系统调用fork()前调用pipe(),否则子进程将不会继承 #文件描述符. 命名管道FIFO\n错误信息 信号\n定义 信号是软中断,可以作为进程间通信的一种机制 的 信号的来源 信号量 # 共享内存 # 消息队列 # 存储器管理概述 # 存储器结构层次 # 存储层次结构部分 # 层次结构 主要组成 第一层次 寄存器\n高速缓冲存储器 第二层次 内存\n磁盘缓存 第三层次 磁盘\n可移动存储介质 层次越高,价格越高,访问速度越快,存储容量越低.\n寄存器.高速缓冲存储器,内存,磁盘缓存都属于操作系统存储管理范围,不可长久保存数据.\n磁盘,可移动存储介质属于操作系统设备管理范围,可以长久保存数据.\n寄存器 访问速度最快,但是价格最昂贵,容量小,通常以字节为单位.用于加速存储访问的速度.如用于存放操作数,用作地址寄存器或变址寄存器,以加快地址变换速度等. 高速缓冲存储器 由硬件寄存器构成,存取速度相当快 内存 内存又称作主存,用于存放进程运行时的程序和数据 磁盘缓存 磁盘的输入输出 用户程序的处理过程😉 # 系统对用户程序的处理过程 系统对用户程序的处理分为以下几个阶段: 编译. 由编译程序将用户源代码编译成若干个目标模块. 链接 由链接程序将编译后形成的目标代码以及它们所需的库函数链接在一起,形成一个装入模块 装入 由装入程序将装入模块装入内存 目标程序装入内存的方式 存储空间及重定位 # 分区存储管理 # 单道程序的连续分配 # 固定分区分配方式 # 动态分区分配 # 可重定位分区 # 页式存储管理 # 页式存储管理思想 # 页式存储管理的数据结构 # 页式存储管理的重定位 # 快表 # 两级和多级页表 # 段式存储管理 # 段式存储管理思想 # 段页式存储管理 # 虚拟存储器 # 局部性原理 # 对换 # 覆盖 # 虚拟存储器 # 请求分页内存管理 # 请求分页的实现 # 内存分配 # 页面置换算法 # 先进先出页面置换算法 # 最近最久未使用页面置换算法 # 最佳置换算法 # 时钟置换算法 # 抖动与工作集 # 请求分段存储管理 # 请求分段的原理和硬件支持 # 段的共享与保护 # 段的共享与保护的实现 # Linux系统的内存管理方法 # Linux分页管理机制 # 虚存段的组织与管理 # 内存的共享和保护 # 内存空间管理 # 空闲内存管理 # 内核态内存的申请与释放 # 用户态内存的申请和释放 # 交换空间 # 页交换进程和页面换出 # 缺页中断和页面换入 # 物理内存 # 系统硬件提供的内存大小.\n虚拟内存 # 利用磁盘空间\n内存查看工具 free命令 vmstat命令 虚拟文件系统proc /proc/meminfo目录下 关于main的参数\nmain(int argc,char *argc[],char *envp[]) 概念： # 虚拟内存(Virtual Memory)： # 首先需要强调的是虚拟内存不同于物理内存，虽然两者都包含内存字眼但是它们属于两个不同层面的概念。进程占用虚拟内存空间大并非意味着程序的物理内存也一定占用很大。\n虚拟内存是操作系统内核为了对进程地址空间进行管理(process address space management)而精心设计的一个逻辑意义上的内存空间概念。我们程序中的指针其实都是这个虚拟内存空间中的地址。比如我们在写完一段C程序之后都需要采用gcc进行编译，这时候编译器采用的地址其实就是虚拟内存空间的地址。因为这时候程序还没有运行,何谈物理内存空间地址?凡是程序运行过程中可能需要用到的指令或者数据都必须在虚拟内存空间中.既然说虚拟内存是一个逻辑意义上(假象的)的内存空间,为了能够让程序在物理机器上运行，那么必须有一套机制可以让这些假象的虚拟内存空间映射到物理内存空间(实实在在的RAM内存条上的空间)。这其实就是操作系统中页映射表(page table)所做的事情了。内核会为系统中每一个进程维护一份相互独立的页映射表。\n虚拟内存是一个假象的内存空间，在程序运行过程中虚拟内存空间中需要被访问的部分会被映射到物理内存空间中。虚拟内存空间大只能表示程序运行过程中可访问的空间比较大，不代表物理内存空间占用也大。\n驻留内存(Resident Memory)： # 驻留内存，顾名思义是指那些被映射到进程虚拟内存空间的物理内存。进程的驻留内存就是进程实实在在占用的物理内存。一般我们所讲的进程占用了多少内存，其实就是说的占用了多少驻留内存而不是多少虚拟内存。因为虚拟内存大并不意味着占用的物理内存大。\nbss段 # bss segment\n通常是指用来存放程序中未初始化的全局变量的一块内存区域。 bss是英文Block Started by Symbol的简称。 bss段属于静态内存分配。\ndata段 # data segment 通常是指用来存放程序中已初始化的全局变量的一块内存区域。 数据段属于静态内存分配。\nheap(堆)段 # 堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。\n当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）； 当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。\ntext段 # code segment/text segment\n通常是指用来存放程序执行代码的一块内存区域。 这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读(某些架构也允许代码段为可写，即允许修改程序)。 在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。\nstack(展)段 # 栈又称堆栈，是用户存放程序临时创建的局部变量， 也就是说我们函数括弧“{}”中定义的变量(但不包括static声明的变量，static意味着在数据段中存放变量)。 除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。 由于栈的先进先出(FIFO)特点，所以栈特别方便用来保存/恢复调用现场。 从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。\n虚拟内存具体布局 # TEXT段：存放代码； DATA段：存放已经初始化的全局变量和static变量； BSS段：存放未初始化的全局变量和static变量； HEAP：堆，动态内存分配区，堆在进程地址空间中是自低地址向高地址增长； STACK：栈，函数参数传递、局部变量等都放在栈中，栈由高地址向低地址增长。 代码段、数据段和BSS段长度在程序编译之后确定。而HEAP和STACK栈随着程序的运行动态变化。 名称 地址 映像文件 程序的代码段 557448a44000-557447f11000 vm_mem 程序的数据段 7fad4b3d2000-7fad4b5ed000 x86_64-linux-gnu/libc.so.6 程序的堆段 557448a44000-557448a65000 heap 程序的栈段 7ffc6d492000-7ffc6d4b3000 stack Linux多线程 # 两个进程函数 # fork() 函数 在 LINUX 系统创建一个新进程的唯一方法是使用fork()函数.\n函数说明 fork()函数用于在一个已知进程中创建一个新进程,新进程被称为子进程,原进程为父进程.自进程继承了父进程整个进程的地址空间,包括进程的上下文、代码段、进程堆栈、内存信息、打开的文件描述符、符号控制设定、进程优先级、进程组号、当前工作目录、根目录、资源限制和控制终端等.子进程相比而言独有的是进程号,资源使用和计时器等. 父进程的fork()函数返回的是创建的子进程的pid值,而子进程执行的fork()函数返回的值是0,可以通过这个来区分子进程与父进程. fork()函数复制了父进程的大部分内容,使得系统开销很大,而且执行速度也不快. 所需头文件 #include\u0026lt;sys/types.h\u0026gt;/*提供类型pid*/#include\u0026lt;unistd.h\u0026gt; ��数原型 | id_t fork(void) | ��数返回值 | :子进程子进程PID(大于0的整数:父进程-1:出错| exec() 函数 按照我的理解是,终止当前进程的所有内容,运行选择的进程的内容\n函数说明 Linux多进程编程 # 逻辑流与并发流 # 并发 # 逻辑控制流 # 并发流及相关概念 # 并发与并行 # 进程基本概念 # 进程概念、结构与描述 # 什么是进程 # 进程结构 # 进程属性(保存在PCB中) # 进程描述信息 进程控制信息 进程资源信息\n进程状态 就绪 阻塞 运行 进程 双向链表+树形结构 树形结构为父子关系，父节点为父进程，子节点位子进程，用p_pptr 进程实例\n操作进程工具 # ps命令查看进程信息 $ps -ef $pfs-ef|bash here ps -u ps l显示当前用户拥有的进程信息 kill 终止进程 命令后加 \u0026amp; 使进程在后台进行 get_pid\n","externalUrl":null,"permalink":"/engineering/linux/%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/","section":"Engineerings","summary":"常用指令 # vi编辑器 # 命令行指令 vi filename 编辑器内部命令行指令 :set nu 显示行号 :w 保存 :w newfilename 另存为 :/word\t查询单词word :/word\tn N\t(n 向下寻找,N 向上寻找)\ti\t插入 y\t复制 p\t粘贴 d\t删除 w\t切换到下一个单词 :wq\t保存并退出 文件管理指令 # 删除操作 # 删除文件","title":"","type":"engineering"},{"content":"docker-compose: command not found问题的两种常用方法_zhiweicoding的博客-CSDN博客\n","externalUrl":null,"permalink":"/engineering/linux/%E8%99%9A%E6%8B%9F%E6%9C%BA/docker/","section":"Engineerings","summary":"docker-compose: command not found问题的两种常用方法_zhiweicoding的博客-CSDN博客","title":"","type":"engineering"},{"content":" 无法找到软件包 # 更换软件源\nsudo vim /etc/apt/sources.list 在里面添加这些内容\n#添加阿里源 deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse #添加清华源 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse multiverse 或\ndeb http://archive.ubuntu.com/ubuntu/ trusty main universe restricted multiverse``` 然后更新\nsudo apt-get update 配置yum # 1、简介 Yum（全称为 Yellow dog Updater, Modified）是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装\n2、安装yum 2.1检测是否安装 build-essential 包 sudo apt-get install build-essential 或者 apt-get install build-essential 2.2安装yum sudo apt-get install yum 或者 apt-get install yum 2.3检测是否安装成功 输入yum指令，看是否有操作提示\n3、配置yum源 由于是Ubuntu没有yum源，所以要想使用yum安装软件必须要配置yum安装源。在/etc/yum/repos.d/目录下创建两个文件，fedora-163.repo和fedora-updates-163.repo。分别复制以下配置信息保存即可。\nfedora-163.repo配置如下信息\n[fedora] name=Fedora 17 - $basearch - 163.com failovermethod=priority baseurl=http://mirrors.163.com/fedora/releases/17/Everything/$basearch/os/ mirrorlist=https://mirrors.fedoraproject.org/metalink?repo=fedora-17\u0026amp;arch=$basearch enabled=1 metadata_expire=7d gpgcheck=1 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-fedora-$basearch [fedora-debuginfo] name=Fedora 17 - $basearch - Debug - 163.com failovermethod=priority baseurl=http://mirrors.163.com/fedora/releases/17/Everything/$basearch/debug/ mirrorlist=https://mirrors.fedoraproject.org/metalink?repo=fedora-debug-17\u0026amp;arch=$basearch enabled=0 metadata_expire=7d gpgcheck=1 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-fedora-$basearch [fedora-source] name=Fedora 17 - Source - 163.com failovermethod=priority baseurl=http://mirrors.163.com/fedora/releases/17/Everything/source/SRPMS/ mirrorlist=https://mirrors.fedoraproject.org/metalink?repo=fedora-source-17\u0026amp;arch=$basearch enabled=0 metadata_expire=7d gpgcheck=1 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-fedora-$basearch fedora-updates-163.repo配置信息如下\n[updates] name=Fedora 17 - $basearch - Updates - 163.com failovermethod=priority baseurl=http://mirrors.163.com/fedora/updates/17/$basearch/ mirrorlist=https://mirrors.fedoraproject.org/metalink?repo=updates-released-f17\u0026amp;arch=$basearch enabled=1 gpgcheck=1 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-fedora-$basearch [updates-debuginfo] name=Fedora 17 - $basearch - Updates - Debug - 163.com failovermethod=priority baseurl=http://mirrors.163.com/fedora/updates/17/$basearch/debug/ mirrorlist=https://mirrors.fedoraproject.org/metalink?repo=updates-released-debug-f17\u0026amp;arch=$basearch enabled=0 gpgcheck=1 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-fedora-$basearch [updates-source] name=Fedora 17 - Updates Source - 163.com failovermethod=priority baseurl=http://mirrors.163.com/fedora/updates/17/SRPMS/ mirrorlist=https://mirrors.fedoraproject.org/metalink?repo=updates-released-source-f17\u0026amp;arch=$basearch enabled=0 gpgcheck=1 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-fedora-$basearch vim中删除全部使用ggdG即可\n4、执行配置 在终端输入\nyum makecache ","externalUrl":null,"permalink":"/engineering/linux/%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","section":"Engineerings","summary":"无法找到软件包 # 更换软件源","title":"","type":"engineering"},{"content":"产品经理\n找竞品 # 七麦数据\n","externalUrl":null,"permalink":"/engineering/productiondesign/readme/","section":"Engineerings","summary":"产品经理","title":"","type":"engineering"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"npx create-next-app@latest my-app --typescript --tailwind --eslint npx shadcn-ui@latest init shadcn/ui 中文站\n","externalUrl":null,"permalink":"/engineering/frontend/ui/radixui/shadcn/","section":"Engineerings","summary":"npx create-next-app@latest my-app --typescript --tailwind --eslint npx shadcn-ui@latest init shadcn/ui 中文站","title":"shadcn","type":"engineering"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"\u0026lt;script setup\u0026gt; import { ref } from \u0026#39;vue\u0026#39; const count = ref(0) \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;button @click=\u0026#34;count++\u0026#34;\u0026gt;You clicked me {{ count }} times.\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; ","externalUrl":null,"permalink":"/engineering/frontend/vue/vue-component/","section":"Engineerings","summary":"\u0026lt;script setup\u0026gt; import { ref } from \u0026#39;vue\u0026#39; const count = ref(0) \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;button @click=\u0026#34;count++\u0026#34;\u0026gt;You clicked me {{ count }} times.","title":"vue组件开发","type":"engineering"},{"content":"","externalUrl":null,"permalink":"/engineering/full-stack/","section":"Engineerings","summary":"","title":"全栈","type":"engineering"},{"content":"","externalUrl":null,"permalink":"/all/","section":"首页","summary":"","title":"全部文章","type":"page"},{"content":" 创建一个 Vue 应用 # \u0026gt; npm init vue@latest 这一指令将会安装并执行 create-vue，它是 Vue 官方的项目脚手架工具。你将会看到一些诸如 TypeScript 和测试支持之类的可选功能提示：\n✔ Project name: … \u0026lt;your-project-name\u0026gt; ✔ Add TypeScript? … No / Yes ✔ Add JSX Support? … No / Yes ✔ Add Vue Router for Single Page Application development? … No / Yes ✔ Add Pinia for state management? … No / Yes ✔ Add Vitest for Unit testing? … No / Yes ✔ Add Cypress for both Unit and End-to-End testing? … No / Yes ✔ Add ESLint for code quality? … No / Yes ✔ Add Prettier for code formatting? … No / Yes Scaffolding project in ./\u0026lt;your-project-name\u0026gt;... Done. 如果不确定是否要开启某个功能，你可以直接按下回车键选择 No。在项目被创建后，通过以下步骤安装依赖并启动开发服务器：\n\u0026gt; cd \u0026lt;your-project-name\u0026gt; \u0026gt; npm install \u0026gt; npm run dev 你现在应该已经运行起来了你的第一个 Vue 项目！请注意，生成的项目中的示例组件是使用组合式 API 和 \u0026lt;script setup\u0026gt; 编写的，而非选项式 API。下面是一些补充提示：\n推荐的 IDE 配置是 Visual Studio Code + Volar 扩展。如果使用其他编辑器，参考 IDE 支持章节。 更多工具细节，包括与后端框架的整合，我们会在工具链指南进行讨论。 要了解构建工具 Vite 更多背后的细节，请查看 Vite 文档。 如果你选择使用 TypeScript，请阅读 TypeScript 使用指南。 当你准备将应用发布到生产环境时，请运行：\n\u0026gt; npm run build 此命令会在 ./dist 文件夹中为你的应用创建一个生产环境的构建版本。关于将应用上线生产环境的更多内容，请阅读生产环境部署指南。\n安装 # 通过\u0026lt;script\u0026gt;引用 通过CDN使用Vue \u0026lt;script src=\u0026quot;https://unpkg.com/vue@3/dist/vue.global.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; 模板语法 # Vue 使用一种基于 HTML 的模板语法，使我们能够声明式地将其组件实例的数据绑定到呈现的 DOM 上。所有的 Vue 模板都是语法层面合法的 HTML，可以被符合规范的浏览器和 HTML 解析器解析。\n在底层机制中，Vue 会将模板编译成高度优化的 JavaScript 代码。结合响应式系统，当应用状态变更时，Vue 能够智能地推导出需要重新渲染的组件的最少数量，并应用最少的 DOM 操作。\n如果你对虚拟 DOM 的概念比较熟悉，并且偏好直接使用 JavaScript，你也可以结合可选的 JSX 支持直接手写渲染函数而不采用模板。但请注意，这将不会享受到和模板同等级别的编译时优化。\n文本插值 # 最基本的数据绑定形式是文本插值，它使用的是“Mustache”语法 (即双大括号)：\n\u0026lt;span\u0026gt;Message: {{ msg }}\u0026lt;/span\u0026gt; 双大括号标签会被替换为相应组件实例中 msg 属性的值。同时每次 msg 属性更改时它也会同步更新。\n原始 HTML # 双大括号会将数据解释为纯文本，而不是 HTML。若想插入 HTML，你需要使用 v-html 指令：\n\u0026lt;p\u0026gt;Using text interpolation: {{ rawHtml }}\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Using v-html directive: \u0026lt;span v-html=\u0026#34;rawHtml\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;/p\u0026gt; 这里我们遇到了一个新的概念。这里看到的 v-html attribute 被称为一个指令。指令由 v- 作为前缀，表明它们是一些由 Vue 提供的特殊 ‎属性‎，你可能已经猜到了，它们将为渲染的 DOM 应用特殊的响应式行为。这里我们做的事情简单来说就是：在当前组件实例上，将此元素的 innerHTML 与 rawHtml 属性保持同步。\nspan 的内容将会被替换为 rawHtml 属性的值，插值为纯 HTML——数据绑定将会被忽略。注意，你不能使用 v-html 来拼接组合模板，因为 Vue 不是一个基于字符串的模板引擎。在使用 Vue 时，应当使用组件作为 UI 重用和组合的基本单元。\n::: warning 警告\n在网站上动态渲染任意 HTML 是非常危险的，因为这非常容易造成 XSS 漏洞。请仅在内容安全可信时再使用 v-html，并且永远不要使用用户提供的 HTML 内容。\n:::\nAttribute 绑定 # 双大括号不能在 HTML attributes 中使用。想要响应式地绑定一个 attribute，应该使用 v-bind 指令：\n\u0026lt;div v-bind:id=\u0026#34;dynamicId\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; v-bind 指令指示 Vue 将元素的 id attribute 与组件的 dynamicId 属性保持一致。如果绑定的值是 null 或者 undefined，那么该 attribute 将会从渲染的元素上移除。\n简写 # 因为 v-bind 非常常用，我们提供了特定的简写语法：\n\u0026lt;div :id=\u0026#34;dynamicId\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 开头为 : 的 attribute 可能和一般的 HTML attribute 看起来不太一样，但它的确是合法的 attribute 名称字符，并且所有支持 Vue 的浏览器都能正确解析它。此外，他们不会出现在最终渲染的 DOM 中。简写语法是可选的，但相信在你了解了它更多的用处后，你应该会更喜欢它。\n接下来的指引中，我们都将在示例中使用简写语法，因为这是在实际开发中更常见的用法。\n布尔型 Attribute # 布尔型 attribute 依据 true / false 值来决定 attribute 是否应该存在于该元素上。disabled 就是最常见的例子之一。\nv-bind 在这种场景下的行为略有不同：\n\u0026lt;button :disabled=\u0026#34;isButtonDisabled\u0026#34;\u0026gt;Button\u0026lt;/button\u0026gt; 当 isButtonDisabled 为真值或一个空字符串 (即 \u0026lt;button disabled=\u0026quot;\u0026quot;\u0026gt;) 时，元素会包含这个 disabled attribute。而当其为其他假值时 attribute 将被忽略。\n动态绑定多个值 # 如果你有像这样的一个包含多个 attribute 的 JavaScript 对象：\nconst objectOfAttrs = { id: \u0026#39;container\u0026#39;, class: \u0026#39;wrapper\u0026#39; } 通过不带参数的 v-bind，你可以将它们绑定到单个元素上：\n\u0026lt;div v-bind=\u0026#34;objectOfAttrs\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 使用JavaScript表达式 # 至此，我们仅在模板中绑定了一些简单的属性名。但是 Vue 实际上在所有的数据绑定中都支持完整的 JavaScript 表达式：\n{{ number + 1 }} {{ ok ? \u0026#39;YES\u0026#39; : \u0026#39;NO\u0026#39; }} {{ message.split(\u0026#39;\u0026#39;).reverse().join(\u0026#39;\u0026#39;) }} \u0026lt;div :id=\u0026#34;`list-${id}`\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 这些表达式都会被作为 JavaScript ，以组件为作用域解析执行。\n在 Vue 模板内，JavaScript 表达式可以被使用在如下场景上：\n在文本插值中 (双大括号) 在任何 Vue 指令 (以 v- 开头的特殊 attribute) attribute 的值中 仅支持表达式 # 每个绑定仅支持单一表达式，也就是一段能够被求值的 JavaScript 代码。一个简单的判断方法是是否可以合法地写在 return 后面。\n因此，下面的例子都是无效的：\n\u0026lt;!-- 这是一个语句，而非表达式 --\u0026gt; {{ var a = 1 }} \u0026lt;!-- 条件控制也不支持，请使用三元表达式 --\u0026gt; {{ if (ok) { return message } }} 调用函数 # 可以在绑定的表达式中使用一个组件暴露的方法：\n\u0026lt;span :title=\u0026#34;toTitleDate(date)\u0026#34;\u0026gt; {{ formatDate(date) }} \u0026lt;/span\u0026gt; ::: tip\n绑定在表达式中的方法在组件每次更新时都会被重新调用，因此不应该产生任何副作用，比如改变数据或触发异步操作。\n:::\n受限的全局访问 # 模板中的表达式将被沙盒化，仅能够访问到有限的全局对象列表。该列表中会暴露常用的内置全局对象，比如 Math 和 Date。\n没有显式包含在列表中的全局对象将不能在模板内表达式中访问，例如用户附加在 window 上的属性。然而，你也可以自行在 app.config.globalProperties 上显式地添加它们，供所有的 Vue 表达式使用。\n指令语法 # 指令是带有 v- 前缀的特殊 attribute。Vue 提供了许多内置指令，包括上面我们所介绍的 v-bind 和 v-html。\n指令 attribute 的期望值为一个 JavaScript 表达式 (除了少数几个例外，即之后要讨论到的 v-for、v-on 和 v-slot)。一个指令的任务是在其表达式的值变化时响应式地更新 DOM。以 v-if 为例：\n\u0026lt;p v-if=\u0026#34;seen\u0026#34;\u0026gt;Now you see me\u0026lt;/p\u0026gt; 这里，v-if 指令会基于表达式 seen 的值的真假来移除/插入该 \u0026lt;p\u0026gt; 元素。\n参数 Arguments # 某些指令会需要一个“参数”，在指令名后通过一个冒号隔开做标识。例如用 v-bind 指令来响应式地更新一个 HTML attribute：\n\u0026lt;a v-bind:href=\u0026#34;url\u0026#34;\u0026gt; ... \u0026lt;/a\u0026gt; \u0026lt;!-- 简写 --\u0026gt; \u0026lt;a :href=\u0026#34;url\u0026#34;\u0026gt; ... \u0026lt;/a\u0026gt; 这里 href 就是一个参数，它告诉 v-bind 指令将表达式 url 的值绑定到元素的 href attribute 上。在简写中，参数前的一切 (例如 v-bind:) 都会被缩略为一个 : 字符。\n另一个例子是 v-on 指令，它将监听 DOM 事件：\n\u0026lt;a v-on:click=\u0026#34;doSomething\u0026#34;\u0026gt; ... \u0026lt;/a\u0026gt; \u0026lt;!-- 简写 --\u0026gt; \u0026lt;a @click=\u0026#34;doSomething\u0026#34;\u0026gt; ... \u0026lt;/a\u0026gt; 这里的参数是要监听的事件名称：click。v-on 有一个相应的缩写，即 @ 字符。我们之后也会讨论关于事件处理的更多细节。\n动态参数 # 同样在指令参数上也可以使用一个 JavaScript 表达式，需要包含在一对方括号内：\n\u0026lt;!-- 注意，参数表达式有一些约束， 参见下面“动态参数值的限制”与“动态参数语法的限制”章节的解释 --\u0026gt; \u0026lt;a v-bind:[attributeName]=\u0026#34;url\u0026#34;\u0026gt; ... \u0026lt;/a\u0026gt; \u0026lt;!-- 简写 --\u0026gt; \u0026lt;a :[attributeName]=\u0026#34;url\u0026#34;\u0026gt; ... \u0026lt;/a\u0026gt; 这里的 attributeName 会作为一个 JavaScript 表达式被动态执行，计算得到的值会被用作最终的参数。举例来说，如果你的组件实例有一个数据属性 attributeName，其值为 \u0026quot;href\u0026quot;，那么这个绑定就等价于 v-bind:href。\n相似地，你还可以将一个函数绑定到动态的事件名称上：\n\u0026lt;a v-on:[eventName]=\u0026#34;doSomething\u0026#34;\u0026gt; ... \u0026lt;/a\u0026gt; \u0026lt;!-- 简写 --\u0026gt; \u0026lt;a @[eventName]=\u0026#34;doSomething\u0026#34;\u0026gt; 在此示例中，当 eventName 的值是 \u0026quot;focus\u0026quot; 时，v-on:[eventName] 就等价于 v-on:focus。\n动态参数值的限制 # 动态参数中表达式的值应当是一个字符串，或者是 null。特殊值 null 意为显式移除该绑定。其他非字符串的值会触发警告。\n动态参数语法的限制 # 动态参数表达式因为某些字符的缘故有一些语法限制，比如空格和引号，在 HTML attribute 名称中都是不合法的。例如下面的示例：\n\u0026lt;!-- 这会触发一个编译器警告 --\u0026gt; \u0026lt;a :[\u0026#39;foo\u0026#39; + bar]=\u0026#34;value\u0026#34;\u0026gt; ... \u0026lt;/a\u0026gt; 如果你需要传入一个复杂的动态参数，我们推荐使用计算属性替换复杂的表达式，也是 Vue 最基础的概念之一，我们很快就会讲到。\n当使用 DOM 内嵌模板 (直接写在 HTML 文件里的模板) 时，我们需要避免在名称中使用大写字母，因为浏览器会强制将其转换为小写：\n\u0026lt;a :[someAttr]=\u0026#34;value\u0026#34;\u0026gt; ... \u0026lt;/a\u0026gt; 上面的例子将会在 DOM 内嵌模板中被转换为 :[someattr]。如果你的组件拥有 “someAttr” 属性而非 “someattr”，这段代码将不会工作。单文件组件内的模板不受此限制。\n修饰符 Modifiers # 修饰符是以点开头的特殊后缀，表明指令需要以一些特殊的方式被绑定。例如 .prevent 修饰符会告知 v-on 指令对触发的事件调用 event.preventDefault()：\n\u0026lt;form @submit.prevent=\u0026#34;onSubmit\u0026#34;\u0026gt;...\u0026lt;/form\u0026gt; 之后在讲到 v-on 和 v-model 的功能时，你将会看到其他修饰符的例子。\n最后，在这里你可以直观地看到完整的指令语法：\n响应式基础 # 使用reactive()函数创建一个响应式对象或数组：\nimport { reactive } from \u0026#39;vue\u0026#39; 要在组件模板中使用响应式状态，需要在 setup() 函数中定义并返回。\n响应式函数经常用做事件监听器\n举例：\n\u0026lt;template\u0026gt; \u0026lt;button @click=\u0026#34;increment\u0026#34;\u0026gt; {{ state.count }} \u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import { reactive } from \u0026#39;vue\u0026#39; export default { // `setup` 是一个专门用于组合式 API 的特殊钩子函数 setup() { const state = reactive({ count: 0 }) function increment() { state.count++ } // 不要忘记同时暴露 increment 函数 return { state, increment } } } \u0026lt;/script\u0026gt; \u0026lt;script setup\u0026gt; # 在 setup() 函数中手动暴露大量的状态和方法非常麻烦，需要我们手动将所有的变量进行retrun出来。但是，我们可以通过使用构建工具来简化该操作。当使用单文件组件（SFC）时，我们可以使用 \u0026lt;script setup\u0026gt; 来大幅度地简化代码。\n\u0026lt;script setup\u0026gt; import { reactive } from \u0026#39;vue\u0026#39; const state = reactive({ count: 0 }) function increment() { state.count++ } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;button @click=\u0026#34;increment\u0026#34;\u0026gt; {{ state.count }} \u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; ","externalUrl":null,"permalink":"/engineering/frontend/vue/vue3-start-setup/","section":"Engineerings","summary":"创建一个 Vue 应用 # \u0026gt; npm init vue@latest 这一指令将会安装并执行 create-vue，它是 Vue 官方的项目脚手架工具。你将会看到一些诸如 TypeScript 和测试支持之类的可选功能提示：","title":"初始化","type":"engineering"},{"content":"","externalUrl":null,"permalink":"/engineering/backend/","section":"Engineerings","summary":"","title":"后端技术","type":"engineering"},{"content":" 快速排序 # 主要思想: # 在数组中选择一个值，然后遍历数组，比这个值大的放到这个值后边，比这个值小的放到这个值的前边。\n代码实现 # void quick_sort(int q[], int l, int r){ if(l \u0026gt;= r) return; int x = q[(l + r) \u0026gt;\u0026gt; 1], i = l - 1, j = r + 1; while(i \u0026lt; j) { do i ++ ; while(q[i] \u0026lt; x); do j -- ; while(q[j] \u0026gt; x); if(i \u0026lt; j) swap(q[i],q[j]); } quick_sort(q,l, j); quick_sort(q,j+1,r); } 为什么最后是j与j+1呢?\n因为范围确保的是左边是小于等于x，右边大于等于x。而循环判断结束的限制是i\u0026lt;j,则可能出现的情况是i=j或i = j + 1。如果是i=j+1那么左边为l到i不满足左边都小于等于x，因为q[i]\u0026gt;x。那为什么不是l到i-1呢？如果是l到i-1那么可能出现只有两个数的情况，然后划分的时候右边化为空集，左边为两个数的数组，此时陷入无尽循环。\n归并排序 # 主要思想: # 将数组拆分为两部分，前半部分和后半部分，然后这两部分分别进行排序。排序完成后从这两个数组开头开始比较，较小的数先插入到数组头位置，以此类推。\n代码实现 # void merged_sort(int a[],int l,int r){ if(l \u0026gt;= r) return; int mid = (l + r)\u0026gt;\u0026gt;1; merged_sort(a,l,mid); merged_sort(a,mid+1,r); int k = l,i = l,j = mid + 1; while(i \u0026lt;= mid\u0026amp;\u0026amp;j \u0026lt;= r){ if(a[i] \u0026lt; a[j]) tmp[k++] = a[i++]; else tmp[k++] = a[j++]; } while(i \u0026lt;= mid) tmp[k++] = a[i++]; while(j \u0026lt;= r) tmp[k++] = a[j++]; for(int i = l; i \u0026lt;= r ;i++) a[i] = tmp[i]; } 二分 # 主要思想 # 假设目标值在闭区间[l, r]中， 每次将区间长度缩小一半，当l = r时，我们就找到了目标值。 有单调性可以二分，使用二分不一定有单调性。\n整数二分 # 选择不同版本主要是看check函数，如果答案在[l, mid]和[mid + 1, r]与[l, mid - 1]和[mid, r]这两种情况中的一种，则需要判断是否在计算mid时多加一\n版本1 # 当我们将区间[l, r]划分成[l, mid]和[mid + 1, r]时，其更新操作是r = mid或者l = mid + 1;，计算mid时不需要加1。\nC++ 代码模板：\nint bsearch_1(int l, int r) { while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (check(mid)) r = mid; else l = mid + 1; } return l; } 版本1 # 当我们将区间[l, r]划分成[l, mid - 1]和[mid, r]时，其更新操作是r = mid - 1或者l = mid;，此时为了防止死循环，计算mid时需要加1。\nC++ 代码模板：\nint bsearch_2(int l, int r) { while (l \u0026lt; r) { int mid = l + r + 1 \u0026gt;\u0026gt; 1; if (check(mid)) l = mid; else r = mid - 1; } return l; } check(mid)函数一般表示数组的mid位是否大于等于要找的值，包含等于的情况则后边修改边界时是l或r等于mid。 两组差别是当更新边界时有l = mid;r = mid - 1;时，在计算mid时需要多加一来向上取整。\n实数二分 # 比如求某个数开根号的结果，可以使用二分。 举个例子，求实数n开三次方的结果，保留6位小数。\ndouble q(double a){return a*a*a;}//求三次方 double sancigen(double n){ double l = -n; double r = n; double mid = 0; while(l - r \u0026gt; 1e-7){//当左右边界很接近的时候 就已经满足了答案。 if(q(mid) \u0026gt; n) r = mid; else l = mid; mid = (l + r) / 2; } return l; } 高精度 # 应用场景 # 如果一个数据很大，大于int与long long的数据表示范围，即[-$2^{31}$,$2^{31} - 1$]和[-$2^{63}$,$2^{63} - 1$]无法表示.那么则需要进行高精度计算.c++中进行长数据运算会出现溢出为负的情况，而java、python没有这种问题（因为一般会自动转换为更大变量）。 一般情况为四种情况，大整数的加减乘除。\n计算前预处理 # 一般情况下，大数据int甚至long long存不下，我们可以使用数组存。一般使用大端模式，即高位存高位，低位存低位，便于高位进位，否则进位时需要把数组整体后移。 用vector存比较方便，因为有size()函数返回长度。 数据12345，在数组中存储的顺序是54321。\n加法 # 计算过程就是类似模拟加减法运算。\nvector\u0026lt;int\u0026gt; addBigInteger(vector\u0026lt;int\u0026gt; \u0026amp;A,vector\u0026lt;int\u0026gt; \u0026amp;B) { vector\u0026lt;int\u0026gt; C; int t = 0; for(int i = 0; i \u0026lt; A.size()|| i \u0026lt; B.size();i++) { if(i \u0026lt; A.size()) t += A[i]; if(i \u0026lt; B.size()) t += B[i]; C.push_back(t%10); t /= 10;//大于10则有进位。 } if(t)//最高位有进位，则再加一。 C.push_back(1); return C; } 减法 # 减法先考虑两个正数相减，其他情况可以转换为绝对值相加减，如两个负数相减可以转换为绝对值相加然后取反，正数负数相减可以转换为绝对值相减然后根据情况添加正负号。 可以先判断两个数哪个更大，用大的减去小的，再根据情况添加正负号。如果出现两个相同的数相减，需要处理前导0。\nbool cmp(vector\u0026lt;int\u0026gt; \u0026amp;A,vector\u0026lt;int\u0026gt; \u0026amp;B){ if(A.size() != B.size()) return A.size() \u0026gt; B.size(); for(int i = A.size() - 1; i \u0026gt;= 0;i--){ if(A[i] != B[i]) return A[i] \u0026gt; B[i]; } return true; } vector\u0026lt;int\u0026gt; subBigInteger(vector\u0026lt;int\u0026gt; \u0026amp;A,vector\u0026lt;int\u0026gt; \u0026amp;B) { vector\u0026lt;int\u0026gt; C; int t = 0; for(int i = 0;i \u0026lt; A.size();i++)//默认A.size()\u0026gt;=B.size() { t = A[i] + t; if(i \u0026lt; B.size()) t -= B[i]; C.push_back((t+10)%10); if(t \u0026gt;= 0) t = 0; else t = -1; //if(t \u0026gt;= 0) C.push_back(t); //else {C.push_back(t + 10);t = -1;} } while(C.size()\u0026gt;1\u0026amp;\u0026amp;C.back() == 0) C.pop_back();//处理前导0 return C; } 乘法 # 乘法一般考虑大数据与小数据相乘，直接模拟计算乘法的过程。\nvector\u0026lt;int\u0026gt; multBigInteger(vector\u0026lt;int\u0026gt; \u0026amp;A,int B) { vector\u0026lt;int\u0026gt; C; for(int i = 0,t =0;i \u0026lt; A.size() || t != 0;i++)//t != 0确保最高位进位 { if(i \u0026lt; A.size()) t = t + A[i] * B; C.push_back(t%10); t = t/10; } while(C.size() \u0026gt; 1 \u0026amp;\u0026amp; C.back() == 0)C.pop_back();//出现一个乘数为0的情况。 return C; } 除法 # 除法也是模拟的方法。不过细节稍微有点不同。\nvector\u0026lt;int\u0026gt; divBigInteger(vector\u0026lt;int\u0026gt; A,int B,int \u0026amp;d) { vector\u0026lt;int\u0026gt; C; d = 0; for(int i = A.size() - 1; i \u0026gt;=0;i--)//除法是从最高位开始除的，所以这里从最高位开始。 { d = A[i] + d*10;//列式除法最下方那个数字 C.push_back(d / B);//列式除法最上方那一行的数字入C； d = d % B;//算完后的余数，留给下一位计算。 } reverse(C.begin(),C.end());//由于C是正向加入，所以这里翻转。 while(C.size() \u0026gt; 1 \u0026amp;\u0026amp; C.back() == 0) C.pop_back();//除去前导0 return C; } 前缀和 # 前缀和是指用一个数组来存前i个数据的和，这样方便计算区间和的值。\n一维前缀和 # const int N = 100010; int s[N]; int a[N]; for(int i = 1; i \u0026lt;= n ;i++) { s[i] = s[i - 1] + a[i]; } 当要计算区间l到r的和时。\nprintf(\u0026#34;%d\u0026#34;,s[r] - s[l - 1]); 二维前缀和 # 计算前缀和数组\nconst int N = 1010; int a[N][N]; int s[N][N]; for(int i = 1;i \u0026lt;= n ;i++){ for(int j = 1;j \u0026lt;= m ;j++){ s[i][j] = a[i][j] + s[i][j - 1] + s[i-1][j] - s[i-1][j-1]; } } 求区间(i,j)到(k,l)内矩形内的和\nprintf(\u0026#34;%d\\n\u0026#34;,s[k][l] - s[k][j - 1] - s[i - 1][l] + s[i - 1][j - 1]); 差分 # 差分是指用一个数组来存相邻数的差，这样方便处理对区间内的数都加上某个数的操作。\n一维差分 # 定义插入函数\nconst int N = 100010; int arr[N]; int b[N]; void insert(int l,int r,int c) { b[l] += c; b[r + 1] -= c; } 区间内减去C\nb[l] = b[l] + c; b[r + 1] = b[r + 1] - c; ``` 求原数组，输出结果 ```cpp for(int i = 1;i \u0026lt;= n ;i++) { b[i] += b[i-1]; } for(int i = 1;i \u0026lt;= n ;i++) { printf(\u0026#34;%d \u0026#34;,b[i]); } 二维差分 # 定义插入函数\nconst int N = 1010; int n,m,q; int arr[N][N]; int b[N][N]; void insert(int x1,int y1,int x2,int y2,int c){ b[x1][y1] += c; b[x2 + 1][y1] -= c; b[x1][y2 + 1] -= c; b[x2 + 1][y2 + 1] += c; } 计算差分数组。\nwhile(q--){ int x1,x2,y1,y2,c; scanf(\u0026#34;%d%d%d%d%d\u0026#34;,\u0026amp;x1,\u0026amp;y1,\u0026amp;x2,\u0026amp;y2,\u0026amp;c); insert(x1,y1,x2,y2,c); } 逆运算求原数组并输出。\nfor(int i = 1; i\u0026lt;=n;i++) for(int j = 1;j\u0026lt;=m;j++){ b[i][j] += b[i-1][j] + b[i][j-1] - b[i-1][j-1]; } for(int i = 1;i \u0026lt;= n;i++){ for(int j = 1; j\u0026lt;=m;j++){ printf(\u0026#34;%d \u0026#34;,b[i][j]); } printf(\u0026#34;\\n\u0026#34;); } 双指针算法 # 一般用i,j两个指针来遍历数组。快速排序也使用了双指针的思想。 核心思想：\n将下面的朴素算法$O(n^2)$优化到$O(n)$\nfor(int i = 0;i\u0026lt;n;i++) { for(int j = 0; j \u0026lt; n ;j ++){ //具体逻辑 check(i,j); } } 基本模板：\nfor(int i = 0,j=0;i\u0026lt;n;i++) { while(i \u0026lt; j\u0026amp;\u0026amp;check(i,j))j++; //具体逻辑 } 求最长不重复子列长度 # 数组不含重复数字的最长子列的长度。 朴素做法是遍历所有i，j。但是根据分析后发现，如果区间内无重复子列，i往后移动出现了重复子列，那么j只有往后移动才可能消去这个子列。往左则不满足i移动前的条件，即当前是最长无重复子列。\nint a[N]; int s[N];//用于确定区间内是否有重复数组，这也可以使用哈希表来判断。 for(int i = 0,j = 0;i \u0026lt; n;i++){ s[a[i]] ++ ; while(s[a[i]] \u0026gt; 1){ //如果存在重复数，则j往前移动 //为什么不往后移动？因为当前j已经是满足上一个i的最右距离，只能往左了。 s[a[j]] --; j ++; } res = max(res,i - j + 1); } 位运算 # 常用操作 # 求n的二进制数的第k位，和第一个1的位置。\nint res = n\u0026gt;\u0026gt;k \u0026amp; 1;//将第k位右移到个位，然后与000001进行和运算。个位为1输出1否则输出0。 int lowbit(int n){ return n\u0026amp;(-n); //return n\u0026amp;(~x + 1); } int num = lowbit(n); 用例 判断一个数的二进制数有多少个1。\nint num = 0; while(x \u0026gt; 0){ x -= lowbit(x); num ++; } printf(\u0026#34;%d \u0026#34;,num); 离散化 # 主要思想 # 在一个长区间，是很长很长的区间中，存在零散的数据。这种情况下找区间内的值，如果一个个遍历会很费时（因为区间很长），所以有了离散化的想法。\n一般是将数据依照顺序来与自然数一一对应.如果有区间那么也添加到其中.\n以一个题目为例: 802. 区间和 - AcWing题库\n全部代码 # #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef pair\u0026lt;int, int\u0026gt; PII; const int N = 300010; int n, m; int a[N], s[N];//定义离散化后的数组,与前缀和数组. vector\u0026lt;int\u0026gt; alls;//存储需要离散化的值,并将其与自然数映射. vector\u0026lt;PII\u0026gt; add, query;//存储添加数据对,与查询数据范围. int find(int x)//根据离散化的数查询自然数对应的位置. { int l = 0, r = alls.size() - 1; while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (alls[mid] \u0026gt;= x) r = mid; else l = mid + 1; } return r + 1;//因为要使用前缀和,所以一般数组以1开头,所以这里加一. } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; n; i ++ ) { int x, c; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; c; add.push_back({x, c}); alls.push_back(x);// } for (int i = 0; i \u0026lt; m; i ++ ) { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; query.push_back({l, r}); alls.push_back(l); alls.push_back(r); } // 去重 sort(alls.begin(), alls.end()); alls.erase(unique(alls.begin(), alls.end()), alls.end()); //担心一个点加两次数却被去重? //这里只存储位置,加数在后边遍历添加数据对中, //如果一个点多加两次,那么add中也有两条对应的. // 处理插入 for (auto item : add) { int x = find(item.first); a[x] += item.second; } // 预处理前缀和 for (int i = 1; i \u0026lt;= alls.size(); i ++ ) s[i] = s[i - 1] + a[i]; // 处理询问 for (auto item : query) { int l = find(item.first), r = find(item.second); cout \u0026lt;\u0026lt; s[r] - s[l - 1] \u0026lt;\u0026lt; endl; } return 0; } 区间合并 # 问题提出 # 给出n个区间范围,如果区间有公共范围,则合并.求最终剩下几个区间.\n主要思路 # 可以按照左端点大小进行排序,然后检查右端点与下一个区间的左端点的关系,如果包含则并入,否则不处理,划分到下一个区间,\n主要代码 # #include\u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; const int N = 100010; typedef pair\u0026lt;int,int\u0026gt; PAIR; vector\u0026lt;PAIR\u0026gt; seg; void merged(vector\u0026lt;PAIR\u0026gt;\u0026amp; seg){ vector\u0026lt;PAIR\u0026gt; res; int st, ed; st = -2e9; ed = -2e9; sort(seg.begin(),seg.end()); for(auto item:seg){ if(ed \u0026lt; item.first){ if(ed != -2e9){ res.push_back({st,ed}); } st = item.first; ed = item.second; }else ed = max(ed,item.second); } if(st != -2e9) res.push_back({st,ed}); seg = res; } int main(){ int n; cin \u0026gt;\u0026gt; n; for(int i = 0 ; i \u0026lt; n ;i ++){ int l , r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; seg.push_back({l,r}); } merged(seg); cout \u0026lt;\u0026lt; seg.size(); return 0; } 大概就是这样了\n","externalUrl":null,"permalink":"/posts/chapter02/acwing/base/base-1/","section":"Posts","summary":"快速排序 # 主要思想: # 在数组中选择一个值，然后遍历数组，比这个值大的放到这个值后边，比这个值小的放到这个值的前边。","title":"基础算法一","type":"posts"},{"content":" 图论 # Floyd算法 # 主要思想是: 循环邻接矩阵中查找每个点到另外一个点的最短距离，不仅是看直接距离，也还要通过计算中转点。比如计算A到B的距离，要比较A到C的距离与C到B的距离的和、A到B的直接距离的最小值来判断，中转点可以是其他节点，所以代码实现中出现了三重循环。\n//n为顶点个数 //第一轮循环为 选取中间点的个数 //第二三轮循环为 void floyd(){ for(int k = 1 ; k \u0026lt;=n ; k++) for(int i = 1 ; i \u0026lt;= n ;i ++) for(int j = 1 ; j \u0026lt;=n ;j ++) dic[i][j] = min(dic[i][j],dic[i][k] + dic[k][j]); } 模板题代码：\n#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 210,INF = 1e9; int dic[N][N]; int n,m,Q; void floyd(){ for(int k = 1 ; k \u0026lt;=n ; k++) for(int i = 1 ; i \u0026lt;= n ;i ++) for(int j = 1 ; j \u0026lt;=n ;j ++) dic[i][j] = min(dic[i][j],dic[i][k] + dic[k][j]); } int main(){ scanf(\u0026#34;%d%d%d\u0026#34;,\u0026amp;n,\u0026amp;m,\u0026amp;Q); for(int i = 1 ; i \u0026lt;= n ;i ++) for(int j = 1 ; j\u0026lt;=n;j++) if(i == j) dic[i][j] = 0; else dic[i][j] = INF; while(m--) { int a,b,w; scanf(\u0026#34;%d%d%d\u0026#34;,\u0026amp;a,\u0026amp;b,\u0026amp;w); dic[a][b] = min(dic[a][b],w); } floyd(); while(Q--) { int a,b; scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;a,\u0026amp;b); if(dic[a][b] \u0026lt; INF / 2) printf(\u0026#34;%d\u0026#34;,dic[a][b]); else printf(\u0026#34;impossible\u0026#34;); printf(\u0026#34;\\n\u0026#34;); } return 0; } ","externalUrl":null,"permalink":"/posts/chapter02/acwing/base/search_and_graph/","section":"Posts","summary":"图论 # Floyd算法 # 主要思想是: 循环邻接矩阵中查找每个点到另外一个点的最短距离，不仅是看直接距离，也还要通过计算中转点。比如计算A到B的距离，要比较A到C的距离与C到B的距离的和、A到B的直接距离的最小值来判断，中转点可以是其他节点，所以代码实现中出现了三重循环。","title":"搜索与图论","type":"posts"},{"content":" 秦九韶算法 # 使用秦九韶算法可以计算多项式的值，或进制转换。 例子：计算多项式的值。a[i]表示多项式中的x的i次幂的系数。\n#include\u0026lt;iostream\u0026gt; using namespace std; int n,x,ans,a[21]; int main(){ cin\u0026gt;\u0026gt;n; for(int i=0;i\u0026lt;=n;i++) cin\u0026gt;\u0026gt;a[i]; cin\u0026gt;\u0026gt;x; ans=a[n]; for(int i=1;i\u0026lt;=n;i++) ans=ans*x+a[n-i]; cout\u0026lt;\u0026lt;ans; return 0; } 质数 # 针对所有大于1的自然数定义的，只包含1和本身两个约数的自然数叫做质数（素数）。\n质数的判定 # 试除法 # bool is_prime(int n){ if(n \u0026lt; 2) return false; for(int i = 2; i \u0026lt;= n ; i++){ if(n % i == 0) return false; } return true; } O(n); 如果i包含其他因子，那么这因子应该是成双成对出现的。比如12的因子有{1,2,3,4,6,12}。 这里只需要遍历成对中的第一个就可以了， 如果n可以被d整除，证明d是n的一个因子，那么另外一个与其对应的因子是n除以n除以d的商。所以我只需要遍历到第一个因子就可以了，即d满足大于n除以d的商，d大于根号n就OK。时间复杂度可以降到根号n。\nbool is_prime(int n){ if(n \u0026lt; 2) return false; for(int i = 2; i \u0026lt;= n / i ; i++){ if(n % i == 0) return false; } return true; } O(sqrt(n)); 不使用sqrt(i)可以降低时间复杂度，每次循环都会计算一次。如果使用i * i \u0026lt;= n，则可能存在 i * i溢出风险，变成负值。\n分解质因数 # 什么是质因数？\n一个数的某对因子均为质数。比如6的因子有2和3，这对因子就是质因数。 从小到大枚举所有约数。\n试除法 # void divide(int n){ for(int i = 2; i \u0026lt;= n; i++) { if(n % i == 0) { } } } ","externalUrl":null,"permalink":"/posts/chapter02/acwing/base/math/","section":"Posts","summary":"秦九韶算法 # 使用秦九韶算法可以计算多项式的值，或进制转换。 例子：计算多项式的值。a[i]表示多项式中的x的i次幂的系数。","title":"数学相关问题","type":"posts"},{"content":"","externalUrl":null,"permalink":"/engineering/datascience/","section":"Engineerings","summary":"","title":"数据科学","type":"engineering"},{"content":" 链表 # 拿数组模拟链表,其实也就是静态链表. 静态链表的优点是快,但是缺点是必须要提前分配足够空间,并且可能会出现假满状态,即idx到最后但是前边还有很多未使用的节点,\n单链表 # #include\u0026lt;iostream\u0026gt; using namespace std; const int N = 100010; int e[N]; int ne[N]; int idx,head; void init(){ head = -1; idx = 0; } void add_to_head(int x){ e[idx] = x; ne[idx] = head; head = idx++; } //插入到下标为k的后面 void add(int k,int x){ e[idx] = x; ne[idx] = ne[k]; ne[k] = idx ++; } void del(int k){ if(k == -1) head = ne[head]; else ne[k] = ne[ne[k]]; } int main(){ int m; cin \u0026gt;\u0026gt; m; init(); while(m--){ char opt; cin \u0026gt;\u0026gt; opt; if(opt == \u0026#39;H\u0026#39;){ int x; cin \u0026gt;\u0026gt; x; add_to_head(x); }else if(opt == \u0026#39;D\u0026#39;){ int k; cin \u0026gt;\u0026gt; k; del(k-1); }else{ int k,x; cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt;x; add(k - 1,x); } } int index = head; while(index != -1){ cout \u0026lt;\u0026lt; e[index] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; index = ne[index]; } return 0; } 双链表 # 所谓双链表就是每个节点含有前结点位置进而后节点位置.\n#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 100010; int pre[N],ne[N],e[N]; int idx; // 定义0号位为头结点 // 定义1号位为尾结点 void init(){ ne[0] = 1; pre[0] = -1; ne[1] = -1; pre[1] = 0; idx = 2; } void add_head(int x){ e[idx] = x; ne[idx] = ne[0]; pre[idx] = 0; pre[ne[0]] = idx; ne[0] = idx; idx ++; } void add_tail(int x){ e[idx] = x; ne[idx] = 1; pre[idx] = pre[1]; ne[pre[1]] = idx; pre[1] = idx; idx++; } void del(int k){ ne[pre[k]] = ne[k]; pre[ne[k]] = pre[k]; } void add_left(int k,int x){ e[idx] = x; ne[idx] = k; pre[idx] = pre[k]; ne[pre[k]] = idx; pre[k] = idx; idx ++; } void add_right(int k,int x){ e[idx] = x; ne[idx] = ne[k]; pre[idx] = k; pre[ne[k]] = idx; ne[k] = idx; idx++; } int main(){ int m; cin \u0026gt;\u0026gt; m; init(); while(m --){ string opt; int k,x; cin \u0026gt;\u0026gt; opt; if(opt == \u0026#34;L\u0026#34;){ cin \u0026gt;\u0026gt; x; add_head(x); }if(opt == \u0026#34;R\u0026#34;){ cin \u0026gt;\u0026gt; x; add_tail(x); }if(opt == \u0026#34;D\u0026#34;){ cin \u0026gt;\u0026gt; k; del(k + 1); }if(opt == \u0026#34;IL\u0026#34;){ cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; x; add_left(k + 1,x); }if(opt == \u0026#34;IR\u0026#34;){ cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; x; add_right(k + 1,x); } } int j = 0; for(int i = ne[0]; ne[i] != -1; i = ne[i]){ cout\u0026lt;\u0026lt; e[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } return 0; } 栈和队列 # 使用数组实现基本的栈与队列\n模拟栈 # const int N = 1010; //栈 int stk[N],tt = -1; //入栈 stk[++tt] = elem; //出栈 stk[tt--]; //栈是否为空 if tt \u0026lt; 0 stack is empty else stack is not empty 完整操作代码\nconst int N = 100010; int stk[N],idx; //初始化 void init(){ idx = -1; } //插入元素 void push(int x){ stk[++idx] = x; } //取出栈顶元素 int pop(){ int res = stk[idx--]; return res; } //判断是否为空 bool isEmpty(){ if(idx \u0026lt; 0) return true; else return false; } //获取栈顶元素 int pull(){ return stk[idx]; } 模拟队列 # const int N = 1010; //栈 int queue[N],tt,hh; //入队 queue[tail++] = elem; //出队 queue[top++]; 完整操作\nconst int N = 100010; int queue[N],top,tail; //初始化 void init(){ top = -1; tail = -1; } //插入元素到队尾 void push(int x){ queue[++tail] = x; } //弹出队列队首元素 int pop(){ int res = queue[++top]; return res; } //队列是否空 bool isEmpty(){ if(top \u0026gt;= tail) return true; else return false; } //返回队列队首元素 int pull(){ return queue[top + 1]; } 单调栈与单调队列 # 单调栈 # 定义 # 什么是单调栈? 栈中的数据具有单调性.现在有一组数10,3,7,4,12从左到右依次入栈，则如果栈为空或入栈元素值小于栈顶元素值，则入栈；否则，如果入栈则会破坏栈的单调性，则需要把比入栈元素小的元素全部出栈。单调递减的栈反之。\n应用场景 # 给定一个序列,求每个元素左边(或右边)最近的比它小(或大)的元素.其实就是找逆序对,最近的两个构成逆序就输出,未找到就返回-1.\n如下图所示, 4找3,满足,则返回3; 2往前找4,不满足,找3,也不满足,则返回-1; 7往前找2(如果2满足,则无需考虑2之前的数据),满足则返回2. 5往前找7,不满足,则去找2,满足,则返回2. 如果满足逆序则保留,不满足则不保留 (因为如果保留,则当前点不满足,上一个点也不满足,需要多遍历, 例如序列5 4 3 1 2, 考虑3时,5 4是非逆序,那么4不满足,5同样不满足) 这种情况使用栈最好,因为考虑的数据是按照后进先出的顺序读取.\n主要代码 # #include\u0026lt;iostream\u0026gt; using namespace std; const int N = 10010; int stk[N].idx = 0; int main(){ int n; cin \u0026gt;\u0026gt; n; for(int i = 0 ; i \u0026lt; n ; i++){ int x; cin \u0026gt;\u0026gt; x; while(idx \u0026amp;\u0026amp; stk[idx] \u0026gt;= x) idx--; if(idx) cout \u0026lt;\u0026lt; stk[idx] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;-1\u0026#34; \u0026lt;\u0026lt; \u0026#34; \u0026#34;; stk[++idx] = x; } return 0; } 单调队列 # 定义 # 什么是单调队列? 有单调性的队列!\n应用场景 # 输入一个数组,并且有长度为k的滑动窗口不断向右移动,求每移动一次后窗口中元素的最大(小)值.滑动窗口求最值.\n先考虑暴力解法,再进行优化,考虑哪些没有用到却被操作.\n#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1000010; int n,k; int a[N],q[N]; int hh,tt; int main(){ scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;n,\u0026amp;k); for(int i = 0 ; i \u0026lt; n ; i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i]); int hh = 0, tt = 0; for(int i = 0 ; i \u0026lt; n ; i++ ){ //判断队头是否已经滑出窗口,即当窗口长度为3时 //,i = 3,hh = 0时,这个3长度的窗口 已经不包括 队首了 所以需要hh++ //一般情况只需要加一次,所以用的是if 不是while if(hh \u0026lt;= tt \u0026amp;\u0026amp; i - k + 1 \u0026gt; q[hh]) hh++; //队列如果加入新元素后不是单调的,就要出队, //直到满足队列为单调的 // 比如 当前窗口内为 3 -1 -3 , //那么3 -1 就是属于无效数据,因为-3是最小的 //在往后移动的过程中,只要有-3 前边都不考虑 //这种情况 也可以看成 不满足单调性 while(hh \u0026lt;= tt \u0026amp;\u0026amp; a[q[tt]] \u0026gt;= a[i]) tt--; //入队新元素 q[++tt] = i; //只要过了k个数 就要输出队头元素 if(i \u0026gt;= k - 1) printf(\u0026#34;%d \u0026#34;,a[q[hh]]); } printf(\u0026#34;\\n\u0026#34;); hh = tt = 0; for(int i = 0 ; i \u0026lt; n ; i ++){ if(hh \u0026lt;= tt \u0026amp;\u0026amp; i - k + 1 \u0026gt; q[hh]) hh++; while(hh \u0026lt;= tt \u0026amp;\u0026amp; a[q[tt]]\u0026lt;= a[i]) tt--; q[++tt] = i; if(i \u0026gt;= k - 1) printf(\u0026#34;%d \u0026#34;,a[q[hh]]); } return 0; } KMP # KMP是一种字符串匹配算法,该算法充分体现了利用已有信息降低操作数,即时间复杂度. 完整代码\n#include\u0026lt;iostream\u0026gt; using namespace std; const int M = 1e6 + 10, N = 1e5 + 10; //定义 字符串 str 与 模板串 ptn char str[M],ptn[N]; int n,m; // 定义next数组 int ne[N]; int main() { scanf(\u0026#34;%d%s%d%s\u0026#34;,\u0026amp;n,ptn + 1,\u0026amp;m,str+1); //next数组第一位是0 所以从第二位开始 // 计算next数组 for(int i = 2 , j = 0 ; i \u0026lt;= n ; i++) { // 如果j是0 就没办法再往前了 // 如果当前与 while(j \u0026amp;\u0026amp; ptn[i] != ptn[j + 1])j = ne[j]; if(ptn[i] == ptn[j+1]) j ++; ne[i] = j; } for(int i = 1 , j = 0 ; i \u0026lt;= m ; i++) { while(j \u0026amp;\u0026amp; str[i] != ptn[j + 1]) j = ne[j]; if(str[i] == ptn[j + 1]) j ++; if(j == n) { printf(\u0026#34;%d \u0026#34;,i - n); j = ne[j]; } } return 0; } Trie树(字典树) # “Trie这个名字取自“retrieval”，检索，因为Trie可以只用一个前缀便可以在一部字典中找到想要的单词。”\n什么是Trie树 # 高效地存储与查找字符串集合的数据结构.用树结构来存储字符串集合,举例: 对于某字符串集合{\u0026quot;abcde\u0026quot;,\u0026quot;abdcf\u0026quot;,\u0026quot;acde\u0026quot;,\u0026quot;acfd\u0026quot;,\u0026quot;abc\u0026quot;,\u0026quot;bd\u0026quot;}.有下面这种存储方法.带星号表示从头往下查找到这个地方算一个字符串, 基本思想 # 如果是存小写字母组成的字符串集合,那么a-z对应的是0-25,如果是大写字母或其他情况同理.每次新加一个字符串中的一个字符,都要给这个字符上一个序号idx.每个需要都要记录它的子节点.比如son[idx][u]记录了序号为idx的子节点u的下一个节点指向的序号.\n打个比方:字符串abcd存入时有这种情况\nson[0][\u0026#39;a\u0026#39; - \u0026#39;a\u0026#39;] = 1;//初始节点的后继节点a的序号是1 son[1][\u0026#39;b\u0026#39; - \u0026#39;a\u0026#39;] = 2;//序号为1的后继节点b的序号是2 son[2][\u0026#39;c\u0026#39; - \u0026#39;a\u0026#39;] = 3;//序号为2的后继节点c的序号是3 son[3][\u0026#39;d\u0026#39; - \u0026#39;a\u0026#39;] = 4;//序号为3的后继节点d的序号是4 如果我继续存入abcf\nson[0][\u0026#39;a\u0026#39; - \u0026#39;a\u0026#39;] = 1;//初始节点的后继节点a的序号是1 son[1][\u0026#39;b\u0026#39; - \u0026#39;a\u0026#39;] = 2;//序号为1的后继节点b的序号是2 son[2][\u0026#39;c\u0026#39; - \u0026#39;a\u0026#39;] = 3;//序号为2的后继节点c的序号是3 //abcf中abc节点都已经存过,所以不需要增加序号 //f属于abc这一子树的新节点,所以需要赋予新序号5 //如果要查找abcf后续节点x,则需要从5开始 //即son[5][x - \u0026#39;a\u0026#39;] = idx; idx表示 x 的序号,如果不存在则为0; son[3][\u0026#39;f\u0026#39; - \u0026#39;a\u0026#39;] = 5;//序号为3的后继节点f的序号是5 那么又一个问题来了。我怎么知道往下哪个是字符串结束呢？比如我存入abc和abcd两个字符串。怎么判断abc在里面。这里我们使用一个cnt[p]数组，该数组存的是以序号p的字符结尾的字符串个数. 。 依托这个数组,我们可以得到在字符串集合{\u0026quot;abc\u0026quot;,\u0026quot;abcd\u0026quot;}中cnt[3] = 1; cnt[4] = 1;代表以字符序号为3和4结尾的字符串各出现了一次.\n主要代码 # #include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1e5 + 10; //son[i][j] 表示编号为i的j儿子的后继节点数 int son[N][26],cnt[N]; char str[N]; int n,idx; void insert(char x[]) { int p = 0; for(int i = 0 ; x[i] ;i++) { int u = x[i] - \u0026#39;a\u0026#39;; //如果不存在节点，则新建一个，然后新节点标号为++idx。 //++idx表示给新节点上个序号,盖个出生证明 if(!son[p][u]) son[p][u] = ++idx; //如何找到下一个节点? //son[p][u]为节点序号为 //p的节点的子节点为u的节点的下一个节点序号 p = son[p][u]; } //表示以节点序号为p结尾的字符串个数. cnt[p] ++; } int query(char x[]) { int p = 0; for(int i = 0 ; x[i] ; i++) { int u = x[i] - \u0026#39;a\u0026#39;; if(!son[p][u]) return 0 ; p = son[p][u]; } return cnt[p]; } int main() { scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); while(n --){ char opt; cin \u0026gt;\u0026gt; opt \u0026gt;\u0026gt; str; if(opt == \u0026#39;I\u0026#39;)insert(str); else printf(\u0026#34;%d\\n\u0026#34;,query(str)); } return 0; } 并查集 # 应用场景 # 适用于维护集合之间的合并，与查询两个数是否在同一个集合内的情况。\n核心代码 # int p[N]; // 压缩路径版本 // 即每次查询 都将集合中的节点指向根节点 int find(int x){ if (p[x] != x) p[x] = find(p[x]); return p[x]; } // 预处理，代表每一个数都属于单独的集合，集合编号为i for(int i = 1 ; i \u0026lt;= n ; i++) p[i] = i; //合并操作 void merge(int a,int b) { p[find(a)] = find(b); } //查询操作 void query(int a,int b) { if(find(a) == find(b)) puts(\u0026#34;Yes\u0026#34;); else puts(\u0026#34;No\u0026#34;); } 哈希表 # 哈希表存储结构 # 将一个集合中的数通过一个函数映射到另外一个集合中。例如离散化中，将大范围中的数据映射到小范围的区间上，这是一种哈希映射，但这种映射需要保存前后顺序，属于特殊的哈希映射。哈希表一般指比较一般情况下的映射。\n但是哈希映射函数可能会出现哈希冲突的情况，比如有一个数据范围为0~1e9的数组，映射到0~1e5范围内，使用的映射函数为h(x) = x MOD 1e5，这种情况可能会出现某两个数经过哈希映射函数计算的哈希值相同，就发生了冲突。这就是所谓的哈希冲突，解决哈希冲突一般有两种方法：开放寻址法和拉链法。\n开放寻址法 # 所谓开放寻址，就是某个点如果发生哈希冲突，就在这个点哈希值加一位置插入数据，如果这个点还有数，就继续往后加，直到为空。\n#include\u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; //一般取质数情况下，发生哈希冲突的概率较低。 //开放寻址法 一般要数组开大一点. //因为h[N]存的是哈希值为N的值是多少 const int N = 200003,null = 0x3f3f3f3f; //按位寻址法 int h[N]; int find(int x) { //负数模后是负数，所以加N int k = (x % N + N) % N; while(h[k] != null \u0026amp;\u0026amp; h[k] != x){ k++; //找到头还没找到 就从0开始 //一般不会出现找不到的情况，有的话就把数组开大 if(k == N) k = 0; } return k; } int main(){ int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); //初始化全部为null 以便标记该位置没存过数 memset (h, null , sizeof h); while(n --) { char opt[2]; int x; scanf(\u0026#34;%s%d\u0026#34;,opt,\u0026amp;x); //先找到位置，如果是没有的话就返回null。 //插入就是把null赋值为x //查找的话 是null就是没找到 int k = find(x); if(*opt == \u0026#39;I\u0026#39;) h[k] = x; else { if(h[k] != null) puts(\u0026#34;Yes\u0026#34;); else puts(\u0026#34;No\u0026#34;); } } return 0; } 拉链法 # 所谓拉链法，就是某个点如果发生哈希冲突，就在这个点上建立一个链表，然后把数加到链表上。\n#include\u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; //一般取质数情况下，发生哈希冲突的概率较低。 const int N = 100003; // 拉链法 //定义链表，e[idx]存序号为idx的数值，ne[idx]存序号为idx的下一项; // h[k]存哈希值为k的第一个数的idx序号 int h[N],e[N],ne[N],idx; void insert(int x) { //负数模后是负数，所以加N int k = (x % N + N) % N; e[idx] = x; ne[idx] = h[k]; h[k] = idx ++; } bool find(int x) { int k = (x % N + N) % N; for(int i = h[k]; i != -1 ; i = ne[i]) { if(e[i] == x) return true; } return false; } int main(){ int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); //初始化全部为-1 以便标记为空 memset (h, -1 , sizeof h); while(n --) { char opt[2]; int x; scanf(\u0026#34;%s%d\u0026#34;,opt,\u0026amp;x); if(*opt == \u0026#39;I\u0026#39;) insert(x); else { if(find(x)) puts(\u0026#34;Yes\u0026#34;); else puts(\u0026#34;No\u0026#34;); } } return 0; } 字符串哈希 # 将字符串转换为一串数字然后计算哈希值存入哈希表，如abcde中每个字母对应的ASCII码中的编号按顺序为1 2 3 4 5（计算方法为'a' - 'a' + 1，'b' - 'a' + 1，'c' - 'a' + 1等）那么可以将这段数字转换为P进制数，这样就可以区分不同字符串对应的哈希值。但是如果字符串位数比较多，会出现哈希值溢出的情况，那么就需要取模Q运算！\n//一般情况下 P = 131;//P = 131; Q = 1 \u0026lt;\u0026lt; 64; 也可以利用这个算法实现前缀哈希，即某个字符串前i位的哈希值。然后我们就可以通过这个数组计算某个子串的哈希值。\n","externalUrl":null,"permalink":"/posts/chapter02/acwing/base/datestruct/","section":"Posts","summary":"链表 # 拿数组模拟链表,其实也就是静态链表.","title":"数据结构","type":"posts"},{"content":" 数据结构 # vector[可变数组] # vector是一种变长数组，即可以自动改变长度的数组。 头文件\n#include\u0026lt;vector\u0026gt; 初始化\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; using namespace std; int main () { //几种初始化的方法 vector\u0026lt;int\u0026gt; a;//定义一个vector 未初始化 输出》 0 vector\u0026lt;int\u0026gt; a(3);//定义一个长度为3的vector 未初始化 输出》0 0 0 vector\u0026lt;int\u0026gt; a(10, 3); //定义一个长度为10，且每个数赋值为3 //将向量b中从下标0 1 2（共三个）的元素赋值给a，a的类型为int型 //它的初始化不和数组一样 vector\u0026lt;int\u0026gt;a(b.begin(),b.begin+3); //从数组中获得初值 int b[7]={1,2,3,4,5,6,7}; vector\u0026lt;int\u0026gt; a(b,b+7）; for(auto x : a) {//遍历输出 cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } return 0; } 相关函数\na.size();//返回元素个数 a.resize();//改变大小 a.empty();//判断a是否为空，空则返回true，非空则返回false a.front(); //返回a的第1个元素,当且仅当a存在 a.back(); //返回vector的最后一个数 a.clear(); //清空a中的元素 a.pop_back(); //删除a向量的最后一个元素 a.push_back(5); //在a的最后一个向量后插入一个元素，其值为5 a.begin();// vector的第0个数 a.end();// vector的最后一个的数的后面一个数 //通常与for循环结合使用 ⑦倍增的思想\n[C++]系统为某一程序分配空间的所需时间，与空间大小无关，与申请次数有关如申请一个空间为1000 和 空间为1 申请1000次的所需时间差别是很大的，申请次数越多，越耗时间 支持比较运算 比较操作如==，！=，\u0026lt;，\u0026lt;，\u0026lt;=，\u0026gt;，\u0026gt;=\nint main () { //支持比较运算 vector\u0026lt;int\u0026gt; a(4, 3), b(3, 4); //a: 3 3 3 3 b:4 4 4 //比较原理字典序 (根据最前面那个判断，如果一样就往后比较) if (a \u0026lt; b) { puts(\u0026#34;a \u0026lt; b\u0026#34;); } return 0; } 遍历方法\nint main () { vector\u0026lt;int\u0026gt; a; for (int i = 0; i \u0026lt; 10; i ++) { a.push_back(i); } //三种遍历vector的方法 for (int i = 0; i \u0026lt; a.size(); i ++) { cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } cout \u0026lt;\u0026lt; endl; for (auto i = a.begin(); i != a.end(); i ++) { cout \u0026lt;\u0026lt; *i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } cout \u0026lt;\u0026lt; endl; //C++11的新语法 for (auto x : a) { cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } cout \u0026lt;\u0026lt; endl; return 0; } 结合算法库中的erase() reverse()\na.erase(p)//从a中删除迭代器p指定的元素，p必须指向c中的一个真实元素，不能是最后一个元素end() a.erase(b,e)//从a中删除迭代器对b和e所表示的范围中的元素，返回e vector\u0026lt;int\u0026gt; a={1,2,3,4,5}; reverse(a.begin(),a.end());//a的值为5，4，3，2，1 倒置 string[字符串] # 支持比较运算 比较操作如==，！=，\u0026lt;，\u0026lt;，\u0026lt;=，\u0026gt;，\u0026gt;= 头文件\n#include\u0026lt;string\u0026gt; 初始化\nstring a = \u0026#34;abc\u0026#34;; queue[队列]和priority_queue[优先队列，堆] # stack[栈] # deque[双向队列] # set[集合]和multiset # set（集合），是一个内部自动有序且不含重复元素的容器。 set可以在需要去重复元素的情况大放异彩，节省时间，减少思维量。 要使用set，需要添加头文件： 头文件\n#include\u0026lt;set\u0026gt; 初始化\nset\u0026lt;int\u0026gt; gather; map[映射]和multiset # unordered[哈希表] # bitset[压位] # 算法 # Algorithm[常用算法函数] # 其他 # C++ pair的基本用法总结（整理） - 知乎 `\n","externalUrl":null,"permalink":"/posts/chapter01/argo-datastru/","section":"Posts","summary":"数据结构 # vector[可变数组] # vector是一种变长数组，即可以自动改变长度的数组。 头文件","title":"算法竞赛常用STL","type":"posts"},{"content":" 背包DP # 01背包 # 每件物品最多只用一次。\n有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。 第 i 件物品的体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。\n输出最大价值。 2. 01背包问题 - AcWing题库\n#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1010; int v[N],w[N]; int m,n; int f[N][N]; int main(){ cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n; for(int i = 1; i \u0026lt;= m;i++ ){ cin \u0026gt;\u0026gt; v[i] \u0026gt;\u0026gt; w[i]; } for(int i = 1; i \u0026lt;= m;i++){ for(int j = 0;j\u0026lt;= n;j++) { f[i][j] = f[i - 1][j]; if( j \u0026gt;= v[i]) //当可以装下的空间比第i个大才有可能存在装第i个物品的情况。 f[i][j] = max(f[i][j],f[i - 1][j - v[i]] + w[i]); } } cout \u0026lt;\u0026lt; f[m][n]; return 0; } 优化为二维\n#include\u0026lt;iostream\u0026gt; using namespace std; 状态表示 # f(i,j) 表示从前i个背包中选，选出的总权值小于等于j的集合。 f(i,j)的值为总价值。\n集合 条件 只从前i中选 选出来的总权值 \u0026lt;j的集合 属性：最大值、最小值、数量。 状态计算 # 表示集合的划分 f(i,j)表示\n不包含第i个背包的最优解即f(i-1,j)， 包含第i个背包的最优解即f(i-1,j-w[i])+v[i]。即去掉第i个物品以及总权值减去第i个的权值。 总结： # 第i个背包能不能放，能放就是集合划分第二种，不能放就是第一种。从一步开始走，然后逐渐解决全部问题。\n完全背包 # 每件物品可以用很多次。\n整数划分\n#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1000010,MOD = 1e9; int f[N]; int main(){ int m; cin \u0026lt;\u0026lt; m; f[0] = 1; for(int i = 1; i \u0026amp;lt;= m;i *= 2){ for(int j = i; j \u0026amp;lt;= m ;j++){ f[j] = (f[j] + f[j - i]) % MOD; } } cout \u0026gt;\u0026gt; f[m]; return 0; } 多重背包 # 每件物品\n分组背包 # 有很多组，每组有多种\n线性DP # 最长上升子序列\n#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1010; int n; int a[N],f[N],g[N]; int main(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i = 1 ; i \u0026lt;= n ; i ++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i]); } for(int i = 1 ; i \u0026lt;=n ; i ++){ f[i] = 1; for(int j = 1 ; j \u0026lt; i ; j ++){ if(a[i] \u0026gt; a[j]){ if(f[j] + 1 \u0026gt; f[i]){ f[i] = f[j] + 1; g[i] = j; } } } } int k = 0; for(int i = 1 ; i \u0026lt;= n; i++){ // printf(\u0026#34;%d \u0026#34;,f[i]); if(f[i] \u0026gt; f[k]){ k = i; } } printf(\u0026#34;\\n%d\\n\u0026#34;,f[k]); for(int i = 0 ,len = f[k]; i \u0026lt; len ; i++){ printf(\u0026#34;%d \u0026#34;,a[k]); k = g[k]; } return 0; } 区间DP # 其他 # 3417. 砝码称重 - AcWing题库 砝码称重问题\n#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 110; const int MAX = 2e5+10,B = MAX / 2; int w[N]; bool f[N][MAX]; int main(){ int n,m; m = 0; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i = 1 ; i \u0026lt;= n ; i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;w[i]),m += w[i]; f[0][B] = true; for(int i = 1 ; i \u0026lt;= n ; i++){ for(int j = -m ; j \u0026lt;= m ; j ++){ //以下三种情况只要有一种满足 则f[i][j + B] 就满足. //不选 f[i][j + B] = f[i - 1][j + B]; //选,但是放另外一边 if(j + w[i] \u0026lt;= m)f[i][j + B] |= f[i - 1][j + w[i] + B]; //选,但是放一起 if(j - w[i] \u0026gt;= -m)f[i][j + B] |= f[i - 1][j - w[i] + B]; } } int sum = 0; for(int i = 1 ; i \u0026lt;= m ; i++){ if(f[n][i + B]) sum ++; } printf(\u0026#34;%d\u0026#34;,sum); return 0; } ","externalUrl":null,"permalink":"/posts/chapter02/acwing/base/dp/","section":"Posts","summary":"背包DP # 01背包 # 每件物品最多只用一次。","title":"背包问题","type":"posts"},{"content":"","externalUrl":null,"permalink":"/engineering/auth/","section":"Engineerings","summary":"","title":"认证与鉴权功能","type":"engineering"},{"content":" 与区间有关的问题 # ","externalUrl":null,"permalink":"/posts/chapter02/acwing/base/greedy/","section":"Posts","summary":" 与区间有关的问题 # ","title":"贪心","type":"posts"},{"content":" Vite启动后提示“Network: use \u0026ndash;host to expose“，且无法通过网络IP访问服务 # 解决方法：\nimport vue from \u0026#39;@vitejs/plugin-vue\u0026#39; /** * https://vitejs.dev/config/ * @type {import(\u0026#39;vite\u0026#39;).UserConfig} */ export default { plugins: [vue()], server: {\t// ← ← ← ← ← ← host: \u0026#39;0.0.0.0\u0026#39;\t// ← 新增内容 ← }\t// ← ← ← ← ← ← } ","externalUrl":null,"permalink":"/engineering/frontend/vue/vue-problem/","section":"Engineerings","summary":"Vite启动后提示“Network: use \u0026ndash;host to expose“，且无法通过网络IP访问服务 # 解决方法：","title":"问题汇总","type":"engineering"}]