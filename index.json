[{"content":" STL中常用算法 # STL中定义了常用的一些算法，比如遍历，查找，排序等一些算法。\n遍历 # for_each 查找 # count_if # 函数原型为count_if(v.begin(),v.end(),comp)\nv.begin()为开始，v.end()为结束，comp为自定义判断函数。\n举个例子：\n排序 # 复制与拷贝 # 算术生成 # 集合算法 # ","externalUrl":null,"permalink":"/posts/chapter01/cpp-stl-argo/","section":"Posts","summary":"STL中常用算法 # STL中定义了常用的一些算法，比如遍历，查找，排序等一些算法。","title":"STL中常用算法","type":"posts"},{"content":" STL 中常用算法 # STL 中定义了常用的一些算法，比如遍历，查找，排序等一些算法。\n遍历 # for_each 查找 # count_if # 函数原型为count_if(v.begin(),v.end(),comp)\nv.begin()为开始，v.end()为结束，comp为自定义判断函数。\n举个例子：\n排序 # 复制与拷贝 # 算术生成 # 集合算法 # ","externalUrl":null,"permalink":"/posts/chapter01/cpp/","section":"Posts","summary":"STL 中常用算法 # STL 中定义了常用的一些算法，比如遍历，查找，排序等一些算法。","title":"STL中常用算法1","type":"posts"},{"content":" 时间复杂度 # 对数 ： 每轮排除一半情况 常用于二分法 指数：每轮分别出两倍情况 线性对数：一般为两层循环相互独立，一层为n一层为对数 常常出现在快速排序 空间复杂度 # 位运算 # 位运算有（\u0026amp;、|、^、~、\u0026raquo;、\u0026laquo;）这几种方法，以下为正且位数相同的二进制数进行的位运算，但是还会有其他特殊情况，比如二进制数非正，位数不同的情况。\n符号 描述 运算规则 \u0026amp; 与 两个位都为1时，结果才为1 | 或 两个位都为0时，结果才为0 ^ 异或 两个位相同为0，相异为1 ~ 取反 0变1，1变0 \u0026laquo; 左移 各二进位全部左移若干位，高位丢弃，低位补0 \u0026raquo; 右移 各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不同 按位与运算符（\u0026amp;） # 定义：参加运算的两个数据，按二进制位进行\u0026quot;与\u0026quot;运算。\n运算规则：同时为1才为1，\n0\u0026amp;0=0 0\u0026amp;1=0 1\u0026amp;0=0 1\u0026amp;1=1 //两位同时为1，结果才为1，否则结果为0。 例如：5\u0026amp;7 即 0000 0101\u0026amp; 0000 0111 = 0000 0101，因此 5\u0026amp;7 的值为5。\n注意：负数按补码形式参加按位与运算。\n与运算的用途：\n清零 如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。 取一个数的指定位 比如取数 X=1011 1001 的低4位，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行按位与运算（X\u0026amp;Y=0000 1001）即可得到X的指定位。 判断奇偶 二进制的奇偶数只需要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用if ((a \u0026amp; 1) == 0)代替if (a % 2 == 0)来判断a是不是偶数。 按位或运算符（|） # 定义：参加运算的两个对象，按二进制位进行\u0026quot;或\u0026quot;运算。\n运算规则：有1就为1，\n0|0=0 0|1=1 1|0=1 1|1=1 //参加运算的两个对象只要有一个为1，其值为1。 例如：5|7即 0000 0101| 0000 0111 = 0000 0111，因此，5|7的值得7。　注意：负数按补码形式参加按位或运算。\n或运算的用途：\n常用来对一个数据的某些位设置为1 比如将数 X=1010 1001 的低4位设置为1，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行按位或运算（X|Y=1010 1001）即可得到。 异或运算符（^） # 定义：参加运算的两个数据，按二进制位进行\u0026quot;异或\u0026quot;运算。\n运算规则：不同为1，相同为0\n0^0=0 0^1=1 1^0=1 1^1=0 //参加运算的两个对象，如果两个相应位相同为0，相异为1。 异或的几条性质:\n1、交换律 2、结合律 (a^b)^c == a^(b^c) 3、对于任何数x，都有 x^x=0，x^0=x 4、自反性: a^b^b=a^0=a; 异或运算的用途：\n翻转指定位 比如将数 X=1010 1110 的低4位进行翻转，只需要另找一个数Y，令Y的低4位为1，其余位为0，即Y=0000 1111，然后将X与Y进行异或运算（X^Y=1010 0001）即可得到。\n与0相异或值不变 例如：1010 1110 ^ 0000 0000 = 1010 1110\n交换两个数 例：(不使用中间变量，但是只能只能交换整型)\nvoid Swap(int \u0026amp;a, int \u0026amp;b){ if (a != b){ a ^= b; b ^= a; a ^= b; } } 取反运算符 (~) # 定义：参加运算的一个数据，按二进制进行\u0026quot;取反\u0026quot;运算。\n运算规则：　直接取反\n~1=0 ~0=1 //对一个二进制数按位取反，即将0变1，1变0。 异或运算的用途：\n使一个数的最低位为零 使a的最低位为0，可以表示为：a \u0026amp; ~1。~1的值为 1111 1111 1111 1110，再按\u0026quot;与\u0026quot;运算，最低位一定为0。 因为\u0026quot; ~\u0026ldquo;运算符的优先级比算术运算符、关系运算符、逻辑运算符和其他运算符都高。 左移运算符（\u0026laquo;） # 定义：将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。\n设 a=1010 1110，a = a\u0026laquo; 2 将a的二进制位左移2位、右补0，即得a=1011 1000。\n若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2。\n右移运算符（\u0026raquo;） # 定义：将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。\n例如：a=a\u0026raquo;2 将a的二进制位右移2位，左补0 或者 左补1得看被移数是正还是负。\n操作数每右移一位，相当于该数除以2。\n复合赋值运算符 # 位运算符与赋值运算符结合，组成新的复合赋值运算符，它们是：\n\u0026amp;= 例：a\u0026amp;=b 相当于 a=a\u0026amp;b |= 例：a|=b 相当于 a=a|b \u0026gt;\u0026gt;= 例：a\u0026gt;\u0026gt;=b 相当于 a=a\u0026gt;\u0026gt;b \u0026lt;\u0026lt;= 例：a\u0026lt;\u0026lt;=b 相当于 a=a\u0026lt;\u0026lt;b ^= 例：a^=b 相当于 a=a^b 运算规则：和前面讲的复合赋值运算符的运算规则相似。\n不同长度的数据进行位运算：如果两个不同长度的数据进行位运算时，系统会将二者按右端对齐，然后进行位运算。\n","externalUrl":null,"permalink":"/posts/chapter01/datastru/","section":"Posts","summary":"时间复杂度 # 对数 ： 每轮排除一半情况 常用于二分法 指数：每轮分别出两倍情况 线性对数：一般为两层循环相互独立，一层为n一层为对数 常常出现在快速排序 空间复杂度 # 位运算 # 位运算有（\u0026amp;、|、^、~、\u0026raquo;、\u0026laquo;）这几种方法，以下为正且位数相同的二进制数进行的位运算，但是还会有其他特殊情况，比如二进制数非正，位数不同的情况。","title":"常用算法储备知识","type":"posts"},{"content":"无意识是什么？ 自动机 循环运动\n怎么计组这么多东西？ 还有两门课没学呢!\n","externalUrl":null,"permalink":"/posts/notes/other/00001/","section":"Posts","summary":"无意识是什么？ 自动机 循环运动","title":"无意识？！","type":"posts"},{"content":"不是为了个文凭吧，还是要自己想要去做什么东西？\n不要焦虑\n进一步学习 当前国内计算机现状，\n如何成神？ 做大佬 所谓大佬 都是努力\n知道努力很重要的人，并为之努力的人。\n超越别人努力就行了。\n焦虑来源：看错书，走弯路。我要学习，考研是顺带的东西。 拖延症，今天事情今天做完。\n专注，有事情 就只考研。\n考研没时间玩\n化压力为动力\n成神\n别想着抄底！\n别估分洗脑自己\n说自己考70 70 130 130 想着想着以为自己真能考那么多？\n复试焦虑？初试过了担心？ 初试有信心能过，复试为什么不能？\n找研友，适当玩一小会，放空大脑 出去逛逛，有个兴趣爱好，\n如何高效学习 正确的心态 瞄准目标使劲打 终身学习 培养自己 平复自己 任务拆解能力 整体任务 暑期任务 周报 日报 月报 时间管理能力 合理的学习计划 有学习梯度， 定一下计划吧，比如高数强化，是不是赶得有点紧了， 这也是一门学问。 做完之后能给自己带来多少收益。 学习技巧 给别人讲解 模拟考对自己狠一点 模拟考就是要严格考自己。该扣分就扣， 复习范围大于考试范围 自拍复习法 外接的支持 后期重要 前期准备好，后期才不慌。 对自己狠点\n引用西游记中： 如果三心二意 就去看西游记。\n得之泰然，\n失之淡然，\n争其必然，\n顺其自然。\n费曼学习法 我有学习动力，掌握方法工具。 及时输出。总结也是一种学习，备周！\n2023年6月26日 22:33:39 # 不知道在搞什么 害!认真复习！\n2023年7月9日 00:20:09 # 或许在朋友圈看到了曾经高三同学的生活近况，想起来过往高三复读的正确性和当下自己问题。或许自己当前的问题，如果踏入了没有复读而是跟高中同学报考同一所学校，然后今年毕业自己当下的问题（心理问题）或许就消散了，我觉得是这样的。或许我复读出省是为了选择更好的学业上的成就，但是我确实暂时也没获得什么成就，也就只有考研这条路。。 两条线，事（学）业线和感情线，当前是在事（学）业线上，还是着眼当下吧，即使没有错过，也会遇到新的问题，起码现在在事业线上，先让这条路开花\n续：\n","externalUrl":null,"permalink":"/posts/notes/thinknote/00001/","section":"Posts","summary":"不是为了个文凭吧，还是要自己想要去做什么东西？","title":"暂且第一记","type":"posts"},{"content":"","externalUrl":null,"permalink":"/posts/notes/other/","section":"Posts","summary":"","title":"暂时没名字","type":"posts"},{"content":" 什么是C++标准模板库（STL）？ # 标准模板库 STL（Standard Template Library），是 C++ 标准库的一部分，不需要单独安装，只需要#include 头文件。\nC++ 对模板（Template）支持得很好，STL 就是借助模板把常用的数据结构及其算法都实现了一遍，并且做到了数据结构和算法的分离。\nC++ 语言的核心优势之一就是便于软件的复用。\nC++ 语言有两个方面体现了复用：\n面向对象的继承和多态机制 通过模板的概念实现了对泛型程序设计的支持 C++中的模板，就好比英语作文的模板，只换主题，不换句式和结构。对应到C++模板，就是只换类型，不换方法。\nSTL有什么优势？ # STL封装了很多实用的容器，省时省力，能够让你将更多心思放到解决问题的步骤上，而非费力去实现数据结构诸多细节上，像极了用python时候的酣畅淋漓。\nSTL到底有什么？ # 六大部件:\n容器 分配器 算法 迭代器 适配器 仿函数 自定义 # vector 矢量 # 定义 # 使用前需添加头文件\n#include\u0026lt;vector\u0026gt; using namespace std; 像定义变量一样定义vector变量：\nvector\u0026lt;类型名\u0026gt; 变量名; 类型名可以是int、double、char、struct，也可以是STL容器：vector、set、queue。\nvector\u0026lt;int\u0026gt; name; vector\u0026lt;double\u0026gt; name; vector\u0026lt;char\u0026gt; name; vector\u0026lt;struct node\u0026gt; name; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; name; vector数组就是一个一维数组,如果定义成vector数组的数组，那就是二维数组**。**\nvector\u0026lt;int\u0026gt; array[SZIE]; //二维变长数组 在此，我送你一句话非常受用的话：低维是高维的地址。\n二维数组中，它的一维形式就是地址。例如：\n#include \u0026lt;iostream\u0026gt; using namespace std; int main(){ int arr[3][2];//定义一个3行2列的地址 cout\u0026lt;\u0026lt;arr[0]\u0026lt;\u0026lt;endl; //输出arr第1行的地址 cout\u0026lt;\u0026lt;arr[1]\u0026lt;\u0026lt;endl; //输出arr第2行的地址 cout\u0026lt;\u0026lt;arr[2]\u0026lt;\u0026lt;endl; //输出arr第3行的地址 return 0; } 输出：\n0x61fe00 //arr第1行的地址 0x61fe08 //arr第2行的地址 0x61fe10 //arr第3行的地址 所以，vector容器也可以这样理解。\n常用函数 # 1.构造函数 # vector():创建一个空vector vector(int nSize):创建一个vector,元素个数为nSize vector(int nSize,const t\u0026amp; t):创建一个vector，元素个数为nSize,且值均为t vector(const vector\u0026amp;):复制构造函数 vector(begin,end):复制[begin,end)区间内另一个数组的元素到vector中 2.增加函数 # void push_back(const T\u0026amp; x):向量尾部增加一个元素X iterator insert(iterator it,const T\u0026amp; x):向量中迭代器指向元素前增加一个元素x iterator insert(iterator it,int n,const T\u0026amp; x):向量中迭代器指向元素前增加n个相同的元素x iterator insert(iterator it,const_iterator first,const_iterator last):向量中迭代器指向元素前插入另一个相同类型向量的[first,last)间的数据 3.删除函数 # iterator erase(iterator it):删除向量中迭代器指向元素 iterator erase(iterator first,iterator last):删除向量中[first,last)中元素 void pop_back():删除向量中最后一个元素 void clear():清空向量中所有元素 4.遍历函数 # reference at(int pos):返回pos位置元素的引用 reference front():返回首元素的引用 reference back():返回尾元素的引用 iterator begin():返回向量头指针，指向第一个元素 iterator end():返回向量尾指针，指向向量最后一个元素的下一个位置 reverse_iterator rbegin():反向迭代器，指向最后一个元素 reverse_iterator rend():反向迭代器，指向第一个元素之前的位置 5.判断函数 # bool empty() const:判断向量是否为空，若为空，则向量中无元素 6.大小函数 # int size() const:返回向量中元素的个数 int capacity() const:返回当前向量所能容纳的最大元素值 int max_size() const:返回最大可允许的vector元素数量值 7.其他函数 # void swap(vector\u0026amp;):交换两个同类型向量的数据 void assign(int n,const T\u0026amp; x):设置向量中前n个元素的值为x void assign(const_iterator first,const_iterator last):向量中[first,last)中元素设置成当前向量元素 访问容器内元素 # vector一般有两种访问方式：\n（1）通过下标访问\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; vi; vi.push_back(1); cout\u0026lt;\u0026lt;vi[0]\u0026lt;\u0026lt;endl; return 0; } 输出：\n1 （2）通过迭代器访问\n迭代器（iterator）可以理解为指针：\nvector\u0026lt;类型名\u0026gt;::iterator 变量名; 例如：\nvector\u0026lt;int\u0026gt;::iterator it; vector\u0026lt;double\u0026gt;::iterator it; 举个例子：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 5; i++) { v.push_back(i); } //v.begin()返回v的首元素地址 vector\u0026lt;int\u0026gt;::iterator it=v.begin(); for (int i = 0; i \u0026lt; v.size(); i++) { cout\u0026lt;\u0026lt;it[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } return 0; } 输出：\n0 1 2 3 4 for循环迭代部分也可以写成：\nvector\u0026lt;int\u0026gt;::iterator it=v.begin(); for (int i = 0; i \u0026lt; v.size(); i++) { cout\u0026lt;\u0026lt;*(it+i)\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } 也即是\nit[i] = *(it+i) //这两个写法等价 这是简单的常识，以后不再提及。\n与此同时，迭代器与for循环还有一种优雅的写法。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 5; i++) { v.push_back(i); } //vector的迭代器不支持it\u0026lt;v.end()的写法，因此循环条件只能it!=v.end() for (vector\u0026lt;int\u0026gt;::iterator it=v.begin(); it!=v.end();it++) { cout\u0026lt;\u0026lt;*it\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } return 0; } 此种写法与遍历字符串有异曲同工之妙：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ string str; str=\u0026#34;Hello World\u0026#34;; for (int i = 0; str[i]!=\u0026#39;\\0\u0026#39;; i++) { cout\u0026lt;\u0026lt;str[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } return 0; } 输出：\nH e l l o W o r l d vector常用函数实例解析 # push_back() pop_back() size() clear() insert() erase() （1）push_back()\nvoid std::vector\u0026lt;int\u0026gt;::push_back(const int \u0026amp;__x) 见名知意，push_back(item)就是在vector后面添加一个元素item。\n用例：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 5; i++) { v.push_back(i); } for (int i = 0; i \u0026lt; v.size(); i++) { cout\u0026lt;\u0026lt;v[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } return 0; } 以前还要为定长数组内存分配而苦恼时，现在只需要无脑push_back()就好了。\n（2）pop_back()\nvoid std::vector\u0026lt;int\u0026gt;::pop_back() push和pop时一对反义词，学过数据结构的人都知道，栈元素的压入和弹出就是push和pop。\n须知，pop_back()一次弹出一个元素，vector容器就会减少一个预算。\n之所以叫容器，就是能往里面装一个一个的元素。\n用例：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 5; i++) { v.push_back(i); } cout\u0026lt;\u0026lt;\u0026#34;pop_back前:\u0026#34;\u0026lt;\u0026lt;endl; for (int i = 0; i \u0026lt; v.size(); i++) { cout\u0026lt;\u0026lt;v[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; v.pop_back(); cout\u0026lt;\u0026lt;\u0026#34;pop_back后:\u0026#34;\u0026lt;\u0026lt;endl; for (int i = 0; i \u0026lt; v.size(); i++) { cout\u0026lt;\u0026lt;v[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } return 0; } 输出：\npop_back前: 0 1 2 3 4 pop_back后: 0 1 2 3 （3）size()\nstd::size_t std::vector\u0026lt;int\u0026gt;::size() szie()返回vector中所含元素的个数，时间复杂度为O(1)。\n用例：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 5; i++) { v.push_back(i); } cout\u0026lt;\u0026lt;v.size()\u0026lt;\u0026lt;endl; return 0; } 输出：\n5 （4）clear()\nvoid std::vector\u0026lt;int\u0026gt;::clear() clear()用于一键清空vector中的所有元素，时间复杂度为O(N)，其中N为vector中原属和元素的个数。\n用例：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 5; i++) { v.push_back(i); } for (int i = 0; i \u0026lt; v.size(); i++) { cout\u0026lt;\u0026lt;v[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } v.clear(); cout\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026#34;size = \u0026#34;\u0026lt;\u0026lt;v.size()\u0026lt;\u0026lt;endl; return 0; } 输出：\n0 1 2 3 4 size = 0 （5）insert()\ninsert(__position,__x); insert(要插入的地址，要插入的元素); 参数： __position：– A const_iterator into the %vector. __x:– Data to be inserted. 与push_back()无脑在尾部添加元素不同的是，insert()是根据指定位置在vector中插入元素。\n用例：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 5; i++) { v.push_back(i); } for (int i = 0; i \u0026lt; v.size(); i++) { cout\u0026lt;\u0026lt;v[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } v.insert(v.begin()+2,-1); //将-1插入v[2]的位置 cout\u0026lt;\u0026lt;endl; for (int i = 0; i \u0026lt; v.size(); i++) { cout\u0026lt;\u0026lt;v[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } return 0; } 输出：\n0 1 2 3 4 0 1 -1 2 3 4 （6）erase()\nerase(__position); 同样，与clear()简单粗暴清空vector不同的是erase()，删除指定位置的元素。\nerase()有两种用法：\n删除一个元素 删除一个区间内的元素 1.删除一个元素\nerase(__position); 用例：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 5; i++) { v.push_back(i); } for (int i = 0; i \u0026lt; v.size(); i++) { cout\u0026lt;\u0026lt;v[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } //删除v[3] v.erase(v.begin()+3); cout\u0026lt;\u0026lt;endl; for (int i = 0; i \u0026lt; v.size(); i++) { cout\u0026lt;\u0026lt;v[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } return 0; } 输出：\n0 1 2 3 4 0 1 2 4 2.删除一个区间内的元素\nerase(__positionBegin,__positionEnd); 即是删除[__positionBegin, __positionEnd)区间内的元素，注意：是左闭右开！\n用例：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 5; i++) { v.push_back(i); } for (int i = 0; i \u0026lt; v.size(); i++) { cout\u0026lt;\u0026lt;v[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } //删除v[1]到v[4]的元素 v.erase(v.begin()+1,v.begin()+4); cout\u0026lt;\u0026lt;endl; for (int i = 0; i \u0026lt; v.size(); i++) { cout\u0026lt;\u0026lt;v[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } return 0; } 输出：\n0 1 2 3 4 0 4 vector常见用途 # （1）储存数据\nvector本身可以作为数组使用，而且在一些元素个数不确定的场合可以很好地节省空间。\n（2）用邻接表存储图\n使用vector实现邻接表，更为简单。\nset # set（集合），是一个内部自动有序且不含重复元素的容器。\nset可以在需要去重复元素的情况大放异彩，节省时间，减少思维量。\n要使用set，需要添加头文件：\n#include \u0026lt;set\u0026gt; using namespace std; 定义 # 像定义变量一样定义set变量：\nset\u0026lt;类型名\u0026gt; 变量名; 类型名可以是int、double、char、struct，也可以是STL容器：vector、set、queue。\n用例：\nset\u0026lt;int\u0026gt; name; set\u0026lt;double\u0026gt; name; set\u0026lt;char\u0026gt; name; set\u0026lt;struct node\u0026gt; name; set\u0026lt;set\u0026lt;int\u0026gt;\u0026gt; name; set数组的定义和vector相同：\nset\u0026lt;类型名\u0026gt; array[SIZE]; 例如：\nset\u0026lt;int\u0026gt; arr[10]; 访问set容器内的元素 # set只能通过迭代器(iterator)访问：\nset\u0026lt;int\u0026gt;::iterator it; set\u0026lt;char\u0026gt;::iterator it; 这样，就得到了迭代器it，并且可以通过*it来访问set里的元素。\n注意：\n除了vector和string之外的STL容器都不支持*(it+i)的访问方式，因此只能按照如下方式枚举：\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; int main() { set\u0026lt;int\u0026gt; st; st.insert(5); st.insert(2); st.insert(6); for (set\u0026lt;int\u0026gt;::iterator it = st.begin(); it != st.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; } return 0; } 输出：\n2 5 6 我们可以看到，原本无序的元素，被插入set集合后，set内部的元素自动递增排序，并且自动去除了重复元素。\nset常用函数实例解析 # （1）insert()\n插入元素十分简单。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; int main() { set\u0026lt;char\u0026gt; st; st.insert(\u0026#39;C\u0026#39;); st.insert(\u0026#39;B\u0026#39;); st.insert(\u0026#39;A\u0026#39;); for (set\u0026lt;char\u0026gt;::iterator it = st.begin(); it != st.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; } return 0; } （2）find()\nfind(value)返回的是set中value所对应的迭代器，也就是value的指针（地址）。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; int main() { set\u0026lt;int\u0026gt; st; for (int i = 1; i \u0026lt;= 3; i++) { st.insert(i); } set\u0026lt;int\u0026gt;::iterator it = st.find(2); //在set中查找2，返回其迭代器 cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; // 以上可以直接x携程 cout \u0026lt;\u0026lt; *(st.find(2)) \u0026lt;\u0026lt; endl; return 0; } 输出：\n2 2 （3）erase()\nerase()有两种用法：删除单个元素、删除一个区间内的所有元素。\n1.删除单个元素\n删除单个元素有两种方法：\nst.erase(it)，其中it为所需要删除元素的迭代器。时间复杂度为O(1)。可以结合find()函数来使用。 #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; int main() { set\u0026lt;int\u0026gt; st; st.insert(100); st.insert(200); st.insert(100); st.insert(300); // 删除单个元素 st.erase(st.find(100)); //利用find()函数找到100,然后用erase删除它 st.erase(st.find(200)); for (set\u0026lt;int\u0026gt;::iterator it = st.begin(); it != st.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; } return 0; } 输出：\n300 st.erase(value)，value为所需要删除元素的值。其时间复杂度为O(logN)，N为set内的元素个数。 #include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; int main() { set\u0026lt;int\u0026gt; st; st.insert(100); st.insert(200); st.insert(100); st.insert(300); // 删除单个元素 st.erase(100); for (set\u0026lt;int\u0026gt;::iterator it = st.begin(); it != st.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; } return 0; } 输出：\n200 300 2.删除一个区间内的所有元素\nst.erase(iteratorBegin , iteratorEnd)可以删除一个区间内的所有元素。\n其中iteratorBegin为所需要删除区间的起始迭代器\niteratorEnd为所需要删除区间的结束迭代器的下一个地址\n也即是**[iteratorBegin,iteratorEnd)**\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; //2.删除一个区间内的所有元素 int main() { set\u0026lt;int\u0026gt; st; st.insert(100); st.insert(200); st.insert(100); st.insert(300); set\u0026lt;int\u0026gt;::iterator it = st.find(200); st.erase(it, st.end()); for (it = st.begin(); it != st.end(); it++) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; endl; } return 0; } 输出：\n100 （4）size()\n不难理解，szie()用来实时获得set内元素的个数，时间复杂度为O(1)。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;set\u0026gt; using namespace std; int main() { set\u0026lt;int\u0026gt; st; st.insert(2); st.insert(5); st.insert(4); cout \u0026lt;\u0026lt; st.size() \u0026lt;\u0026lt; endl; return 0; } 输出：\n3 string # map # 定义 # map # map\u0026lt;int,int\u0026gt; maps; 相关函数 # maps.insert() 插入 maps[key] = value;数组方式插入 maps.find(num) 查找一个元素 maps.clear()清空 maps.szie()长度 maps.begin()返回指向map头部的迭代器 maps.end()返回指向map末尾的迭代器 maps.erase(num)删除一个元素。 unordered_map # 与map容器仅有一点不同的是，unordered_map是无序的。其底层采用的是哈希表存储，不会自动对存储的键值对进行排序。\nqueue # priority # stack # pair # algorithm # ","date":"10 November 2022","externalUrl":null,"permalink":"/posts/chapter01/cpp-stl-intro/","section":"Posts","summary":"什么是C++标准模板库（STL）？ # 标准模板库 STL（Standard Template Library），是 C++ 标准库的一部分，不需要单独安装，只需要#include 头文件。","title":"C++ STL","type":"posts"},{"content":"2023-07-03 01:02:34+08:00 感觉自己还是没有十分投入吧，有点自己骗自己的感觉。学习考研没那么容易，明天再接再厉，找回状态。\n","externalUrl":null,"permalink":"/posts/notes/thinknote/00002/","section":"Posts","summary":"2023-07-03 01:02:34+08:00 感觉自己还是没有十分投入吧，有点自己骗自己的感觉。学习考研没那么容易，明天再接再厉，找回状态。","title":"一些话","type":"posts"},{"content":"","externalUrl":null,"permalink":"/posts/chapter02/acwing/base/","section":"Posts","summary":"","title":"","type":"posts"},{"content":"","date":"10 November 2022","externalUrl":null,"permalink":"/posts/chapter01/","section":"Posts","summary":"","title":"第一章|基础知识储备","type":"posts"},{"content":"","externalUrl":null,"permalink":"/posts/notes/thinknote/","section":"Posts","summary":"","title":"小记","type":"posts"},{"content":"你好，欢迎访问！我是一名计算机科学专业的研究生，日常会写一些笔记，分享一些事情。\n包括一些个人笔记，一些记录等。\n这是是近期在做的一些事情\n后续内容我慢慢写，慢慢记录。\nw 当你引用本站点文章时，请加上本站链接并注明。 全部文章 STL中常用算法 \u0026middot;\u0026middot; STL中常用算法1 \u0026middot;\u0026middot; 常用算法储备知识 \u0026middot;\u0026middot; 无意识？！ \u0026middot;\u0026middot; 暂且第一记 \u0026middot;\u0026middot; C++ STL \u0026middot;\u0026middot; 一些话 \u0026middot;\u0026middot; \u0026middot;\u0026middot; 《大问题》阅读随笔 \u0026middot;\u0026middot; DP \u0026middot;\u0026middot; 全部文章 其他 \u0026middot;\u0026middot; 原初号 \u0026middot;\u0026middot; 基础算法一 \u0026middot;\u0026middot; 常用思想方法 拉康 \u0026middot;\u0026middot; 搜索与图论 \u0026middot;\u0026middot; 数据结构 \u0026middot;\u0026middot; 数论 \u0026middot;\u0026middot; 生活 \u0026middot;\u0026middot; 算法竞赛常用STL \u0026middot;\u0026middot; 背包问题 \u0026middot;\u0026middot; 贪心 \u0026middot;\u0026middot; ","date":"10 November 2022","externalUrl":null,"permalink":"/","section":"首页","summary":"你好，欢迎访问！我是一名计算机科学专业的研究生，日常会写一些笔记，分享一些事情。","title":"首页","type":"page"},{"content":"","externalUrl":null,"permalink":"/posts/chapter02/acwing/dp/","section":"Posts","summary":"","title":"","type":"posts"},{"content":"","externalUrl":null,"permalink":"/posts/chapter02/acwing/math/","section":"Posts","summary":"","title":"","type":"posts"},{"content":"","externalUrl":null,"permalink":"/posts/chapter02/acwing/","section":"Posts","summary":"","title":"Acwing","type":"posts"},{"content":"","externalUrl":null,"permalink":"/posts/chapter02/","section":"Posts","summary":"","title":"第二章|基础算法","type":"posts"},{"content":"","externalUrl":null,"permalink":"/posts/notes/","section":"Posts","summary":"","title":"记录和其他","type":"posts"},{"content":"","date":"10 November 2022","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"这是关于页面\n这是首页 正视自己，分析问题。 记录在案!\n道理是曲折的 若将容易得，便作等闲看。 12345678904026\n首先贴一个 github 热力图，激励坚持每日写作更新吧!\n这是哪?是干嘛的?🤔 # 这是个笔记本，什么东西都可能在上边记录。\n自用\n包括一些什么内容？ # 算法学习心得 计算机基础 其他内容 一些提问自问自答 # 为什么要学计算机基础？ # 作为考研党，408 内容囊括了计算机基础的大部分内容，包括计算机如何运行，电脑如何工作，数据如何处理，传输，是基本功；如果不懂基础，你可能会错失很多乐趣。这些内容也被人称为八股文，即工作用不到，考试还喜欢考的“死记硬背”的知识，但其实你自己专门学习后，会发现这些其实很有趣，也很有用。\n为什么要写算法题？ # 写算法题和写数学题一样，通过不断训练来锻炼对于各类数据结构、各类算法思想的使用，从而提高个人的编程水平。\n关于 408 # 选择题 40 2 = 80 分 综合题 70 分 两个数据结构，两个计组，两个操作系统，一个计算机网络。\n人活一世都不容易，年纪轻轻就有这种想法了？\n追求你想要的，守护你在乎的。\n","externalUrl":null,"permalink":"/about/","section":"首页","summary":"这是关于页面","title":"","type":"page"},{"content":"The Big Questions\n\u0026ldquo;哲学就是对智慧的爱。它是对价值重要性的坚持，是对完全陷入生活琐事而仅仅随波逐流的拒斥。我们渴望洞察，企盼理解，但我们的生活被常规攫住了，不时会被那些所谓的“消遣”或“娱乐”活动分神。我们失去的是思考的快乐、理解的挑战、灵感，以及哲学的慰藉。我们都是借着思想而生活的，所以问题的关键不在于是否从事哲学，而在于是接受一种廉价的、没有挑战的替代品，还是试图进行真正的思考。\u0026rdquo;\n","externalUrl":null,"permalink":"/posts/notes/readingnotes/0001/","section":"Posts","summary":"The Big Questions","title":"《大问题》阅读随笔","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":" 背包DP # 01背包 # 每件物品最多只用一次。\n有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。 第 i 件物品的体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。\n输出最大价值。 2. 01背包问题 - AcWing题库\n#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1010; int v[N],w[N]; int m,n; int f[N][N]; int main(){ cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n; for(int i = 1; i \u0026lt;= m;i++ ){ cin \u0026gt;\u0026gt; v[i] \u0026gt;\u0026gt; w[i]; } for(int i = 1; i \u0026lt;= m;i++){ for(int j = 0;j\u0026lt;= n;j++) { f[i][j] = f[i - 1][j]; if( j \u0026gt;= v[i]) //当可以装下的空间比第i个大才有可能存在装第i个物品的情况。 f[i][j] = max(f[i][j],f[i - 1][j - v[i]] + w[i]); } } cout \u0026lt;\u0026lt; f[m][n]; return 0; } 优化为二维\n#include\u0026lt;iostream\u0026gt; using namespace std; 状态表示 # f(i,j) 表示从前i个背包中选，选出的总权值小于等于j的集合。 f(i,j)的值为总价值。\n集合 条件 只从前i中选 选出来的总权值 \u0026lt;j的集合 属性：最大值、最小值、数量。 状态计算 # 表示集合的划分 f(i,j)表示\n不包含第i个背包的最优解即f(i-1,j)， 包含第i个背包的最优解即f(i-1,j-w[i])+v[i]。即去掉第i个物品以及总权值减去第i个的权值。 总结： # 第i个背包能不能放，能放就是集合划分第二种，不能放就是第一种。从一步开始走，然后逐渐解决全部问题。\n完全背包 # 每件物品可以用很多次。\n整数划分\n#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1000010,MOD = 1e9; int f[N]; int main(){ int m; cin \u0026lt;\u0026lt; m; f[0] = 1; for(int i = 1; i \u0026amp;lt;= m;i *= 2){ for(int j = i; j \u0026amp;lt;= m ;j++){ f[j] = (f[j] + f[j - i]) % MOD; } } cout \u0026gt;\u0026gt; f[m]; return 0; } 多重背包 # 每件物品\n分组背包 # 有很多组，每组有多种\n线性DP # 最长上升子序列\n#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1010; int n; int a[N],f[N],g[N]; int main(){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i = 1 ; i \u0026lt;= n ; i ++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i]); } for(int i = 1 ; i \u0026lt;=n ; i ++){ f[i] = 1; for(int j = 1 ; j \u0026lt; i ; j ++){ if(a[i] \u0026gt; a[j]){ if(f[j] + 1 \u0026gt; f[i]){ f[i] = f[j] + 1; g[i] = j; } } } } int k = 0; for(int i = 1 ; i \u0026lt;= n; i++){ // printf(\u0026#34;%d \u0026#34;,f[i]); if(f[i] \u0026gt; f[k]){ k = i; } } printf(\u0026#34;\\n%d\\n\u0026#34;,f[k]); for(int i = 0 ,len = f[k]; i \u0026lt; len ; i++){ printf(\u0026#34;%d \u0026#34;,a[k]); k = g[k]; } return 0; } 区间DP # 其他 # 3417. 砝码称重 - AcWing题库 砝码称重问题\n#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 110; const int MAX = 2e5+10,B = MAX / 2; int w[N]; bool f[N][MAX]; int main(){ int n,m; m = 0; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i = 1 ; i \u0026lt;= n ; i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;w[i]),m += w[i]; f[0][B] = true; for(int i = 1 ; i \u0026lt;= n ; i++){ for(int j = -m ; j \u0026lt;= m ; j ++){ //以下三种情况只要有一种满足 则f[i][j + B] 就满足. //不选 f[i][j + B] = f[i - 1][j + B]; //选,但是放另外一边 if(j + w[i] \u0026lt;= m)f[i][j + B] |= f[i - 1][j + w[i] + B]; //选,但是放一起 if(j - w[i] \u0026gt;= -m)f[i][j + B] |= f[i - 1][j - w[i] + B]; } } int sum = 0; for(int i = 1 ; i \u0026lt;= m ; i++){ if(f[n][i + B]) sum ++; } printf(\u0026#34;%d\u0026#34;,sum); return 0; } ","externalUrl":null,"permalink":"/posts/chapter02/acwing/dp/dp/","section":"Posts","summary":"背包DP # 01背包 # 每件物品最多只用一次。","title":"DP","type":"posts"},{"content":"","externalUrl":null,"permalink":"/posts/notes/readingnotes/","section":"Posts","summary":"","title":"notes","type":"posts"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","externalUrl":null,"permalink":"/all/","section":"首页","summary":"","title":"全部文章","type":"page"},{"content":" 秦九韶算法 # 使用秦九韶算法可以计算多项式的值，或进制转换。 例子：计算多项式的值。a[i]表示多项式中的x的i次幂的系数。\n#include\u0026lt;iostream\u0026gt; using namespace std; int n,x,ans,a[21]; int main(){ cin\u0026gt;\u0026gt;n; for(int i=0;i\u0026lt;=n;i++) cin\u0026gt;\u0026gt;a[i]; cin\u0026gt;\u0026gt;x; ans=a[n]; for(int i=1;i\u0026lt;=n;i++) ans=ans*x+a[n-i]; cout\u0026lt;\u0026lt;ans; return 0; } ","externalUrl":null,"permalink":"/posts/chapter02/acwing/math/others/","section":"Posts","summary":"秦九韶算法 # 使用秦九韶算法可以计算多项式的值，或进制转换。 例子：计算多项式的值。a[i]表示多项式中的x的i次幂的系数。","title":"其他","type":"posts"},{"content":"为什么要记录？\n借用知乎上某位网友对问题“语言和文字有本质上的区别吗？”的回答：\n“文字又是对语言的记录。是为了从时间上，把过去的思维记录下来。所以本质上看文字是语言的扩张，是又一次信息传递的生产力革命。通过文字对语言的记录，使得瞬间的思维得以固定下来，这带来更多的经验。”\n“文字操纵思想，思想操控文字。”\n许多想法总是会在闲余时，在脑子中涌现，这些想法可能包括了一些自己经常思考的问题，比如对自己的某些问题的评价，一些事情的态度等等，但过后又会忘记。所以就想不如有什么思考或者想法，就记录下来吧。\n学习别人之长。\n现在是2023-06-18 00:16:38，午夜。当下目标是考研，大约还有188天，约莫6个月。是当前最要紧之事， 暂且先列一下吧，\n阅读计划（根据当前手里的书）：\n乔布斯专 沙丘 中央重大决策背后的故事（党史） 矛盾论导读 \u0026hellip;.. 当然是有空了读，眼下最重要的还是刷题，学习。 还有就是一个心理问题，下次说）\n努力和努力有用？\n生活处处有机会，看路（找准路子，这个路子可能并不是你以为正确的路子，可能需要超出自己当前的认知，所以说要适时扩大自己的认知，不要被周围的人所困）！\n123\n2023年8月9日\n关于生活，\n家人、朋友、自己、\n时间线 # 2023-07-02 # 记得滚动复习！少抽点时间给线代和概论。\n今天听了高数强化课 因为各种事情学习时间少吧。明天步入正轨\n2023-07-01 # 下半年第一天！不要急躁，一步步来。\n值班 莫得运动 今日 # 高数强化定积分，做例题。 408同步与互斥! 英语单词加阅读，阅读做的不好，不够细致。 明日 # 想一下定目标，每天线性代数和概率论小推进一点。 408继续往后推进 英语 细心！ 。。。。 2023-06-30 # 运动 但是室内 哇，六月最后一天，下半年第一天。 今日 # 高数强化跟进到定积分哩，习题也都跟着做，不过自习室调换确实有点小影响心情 408 操作系统 听完调度算法，题还没做。 英语背了单词，新背了三十多个 好多不会、、 明日 # 晚上可能要值班 不运动了 高数强化把定积分例题做完，快速把强化课过一遍。 408做完课后题，课往后推进一节。 英语背单词加阅读。 2023-06-29 # 小运动 今天原来都周四了。 今日 # 880第二章综合篇剩大题了，然后第三章积分开了，但是有点小困难。 英语只背了单词，因为开会没做题 408计组结束啦，操作系统第一章也结束了。但是和计组联系还是挺多的。 。。。。 明天 # 上午把积分例题做完搞懂，下午多花一个小时做数学， 英语中午抽会时间背单词。 下午加晚上看408 适量运动！ 2023-06-28 # 运动 今日完成 # 880第二章基础篇完成了！ 辅导讲义例题推进了一点。 英语一篇阅读\u0026amp;单词背诵 408 计组 I/O 加中断 计组剩最后一章啦！ 。。 明天 # 880第二章选择题\u0026amp;辅导讲义例题 英语一篇阅读\u0026amp;单词背诵 计组收尾！ 。。。 2023-06-27 # 运动 今日完成 # 880第二章基础题 做不动 因为很多证明题。 概率论基础阶段完成，高数基础阶段全部完成。 英语背单词 到一千词 408 进度到计组 第五章末尾 。 明日任务 # 880第二章基础题做完。 辅导讲义例题推进。 ","externalUrl":null,"permalink":"/posts/notes/thinknote/00000/","section":"Posts","summary":"为什么要记录？","title":"原初号","type":"posts"},{"content":" 快速排序 # 主要思想: # 在数组中选择一个值，然后遍历数组，比这个值大的放到这个值后边，比这个值小的放到这个值的前边。\n代码实现 # void quick_sort(int q[], int l, int r){ if(l \u0026gt;= r) return; int x = q[(l + r) \u0026gt;\u0026gt; 1], i = l - 1, j = r + 1; while(i \u0026lt; j) { do i ++ ; while(q[i] \u0026lt; x); do j -- ; while(q[j] \u0026gt; x); if(i \u0026lt; j) swap(q[i],q[j]); } quick_sort(q,l, j); quick_sort(q,j+1,r); } 为什么最后是j与j+1呢?\n因为范围确保的是左边是小于等于x，右边大于等于x。而循环判断结束的限制是i\u0026lt;j,则可能出现的情况是i=j或i = j + 1。如果是i=j+1那么左边为l到i不满足左边都小于等于x，因为q[i]\u0026gt;x。那为什么不是l到i-1呢？如果是l到i-1那么可能出现只有两个数的情况，然后划分的时候右边化为空集，左边为两个数的数组，此时陷入无尽循环。\n归并排序 # 主要思想: # 将数组拆分为两部分，前半部分和后半部分，然后这两部分分别进行排序。排序完成后从这两个数组开头开始比较，较小的数先插入到数组头位置，以此类推。\n代码实现 # void merged_sort(int a[],int l,int r){ if(l \u0026gt;= r) return; int mid = (l + r)\u0026gt;\u0026gt;1; merged_sort(a,l,mid); merged_sort(a,mid+1,r); int k = l,i = l,j = mid + 1; while(i \u0026lt;= mid\u0026amp;\u0026amp;j \u0026lt;= r){ if(a[i] \u0026lt; a[j]) tmp[k++] = a[i++]; else tmp[k++] = a[j++]; } while(i \u0026lt;= mid) tmp[k++] = a[i++]; while(j \u0026lt;= r) tmp[k++] = a[j++]; for(int i = l; i \u0026lt;= r ;i++) a[i] = tmp[i]; } 二分 # 主要思想 # 假设目标值在闭区间[l, r]中， 每次将区间长度缩小一半，当l = r时，我们就找到了目标值。 有单调性可以二分，使用二分不一定有单调性。\n整数二分 # 选择不同版本主要是看check函数，如果答案在[l, mid]和[mid + 1, r]与[l, mid - 1]和[mid, r]这两种情况中的一种，则需要判断是否在计算mid时多加一\n版本1 # 当我们将区间[l, r]划分成[l, mid]和[mid + 1, r]时，其更新操作是r = mid或者l = mid + 1;，计算mid时不需要加1。\nC++ 代码模板：\nint bsearch_1(int l, int r) { while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (check(mid)) r = mid; else l = mid + 1; } return l; } 版本1 # 当我们将区间[l, r]划分成[l, mid - 1]和[mid, r]时，其更新操作是r = mid - 1或者l = mid;，此时为了防止死循环，计算mid时需要加1。\nC++ 代码模板：\nint bsearch_2(int l, int r) { while (l \u0026lt; r) { int mid = l + r + 1 \u0026gt;\u0026gt; 1; if (check(mid)) l = mid; else r = mid - 1; } return l; } check(mid)函数一般表示数组的mid位是否大于等于要找的值，包含等于的情况则后边修改边界时是l或r等于mid。 两组差别是当更新边界时有l = mid;r = mid - 1;时，在计算mid时需要多加一来向上取整。\n实数二分 # 比如求某个数开根号的结果，可以使用二分。 举个例子，求实数n开三次方的结果，保留6位小数。\ndouble q(double a){return a*a*a;}//求三次方 double sancigen(double n){ double l = -n; double r = n; double mid = 0; while(l - r \u0026gt; 1e-7){//当左右边界很接近的时候 就已经满足了答案。 if(q(mid) \u0026gt; n) r = mid; else l = mid; mid = (l + r) / 2; } return l; } 高精度 # 应用场景 # 如果一个数据很大，大于int与long long的数据表示范围，即[-$2^{31}$,$2^{31} - 1$]和[-$2^{63}$,$2^{63} - 1$]无法表示.那么则需要进行高精度计算.c++中进行长数据运算会出现溢出为负的情况，而java、python没有这种问题（因为一般会自动转换为更大变量）。 一般情况为四种情况，大整数的加减乘除。\n计算前预处理 # 一般情况下，大数据int甚至long long存不下，我们可以使用数组存。一般使用大端模式，即高位存高位，低位存低位，便于高位进位，否则进位时需要把数组整体后移。 用vector存比较方便，因为有size()函数返回长度。 数据12345，在数组中存储的顺序是54321。\n加法 # 计算过程就是类似模拟加减法运算。\nvector\u0026lt;int\u0026gt; addBigInteger(vector\u0026lt;int\u0026gt; \u0026amp;A,vector\u0026lt;int\u0026gt; \u0026amp;B) { vector\u0026lt;int\u0026gt; C; int t = 0; for(int i = 0; i \u0026lt; A.size()|| i \u0026lt; B.size();i++) { if(i \u0026lt; A.size()) t += A[i]; if(i \u0026lt; B.size()) t += B[i]; C.push_back(t%10); t /= 10;//大于10则有进位。 } if(t)//最高位有进位，则再加一。 C.push_back(1); return C; } 减法 # 减法先考虑两个正数相减，其他情况可以转换为绝对值相加减，如两个负数相减可以转换为绝对值相加然后取反，正数负数相减可以转换为绝对值相减然后根据情况添加正负号。 可以先判断两个数哪个更大，用大的减去小的，再根据情况添加正负号。如果出现两个相同的数相减，需要处理前导0。\nbool cmp(vector\u0026lt;int\u0026gt; \u0026amp;A,vector\u0026lt;int\u0026gt; \u0026amp;B){ if(A.size() != B.size()) return A.size() \u0026gt; B.size(); for(int i = A.size() - 1; i \u0026gt;= 0;i--){ if(A[i] != B[i]) return A[i] \u0026gt; B[i]; } return true; } vector\u0026lt;int\u0026gt; subBigInteger(vector\u0026lt;int\u0026gt; \u0026amp;A,vector\u0026lt;int\u0026gt; \u0026amp;B) { vector\u0026lt;int\u0026gt; C; int t = 0; for(int i = 0;i \u0026lt; A.size();i++)//默认A.size()\u0026gt;=B.size() { t = A[i] + t; if(i \u0026lt; B.size()) t -= B[i]; C.push_back((t+10)%10); if(t \u0026gt;= 0) t = 0; else t = -1; //if(t \u0026gt;= 0) C.push_back(t); //else {C.push_back(t + 10);t = -1;} } while(C.size()\u0026gt;1\u0026amp;\u0026amp;C.back() == 0) C.pop_back();//处理前导0 return C; } 乘法 # 乘法一般考虑大数据与小数据相乘，直接模拟计算乘法的过程。\nvector\u0026lt;int\u0026gt; multBigInteger(vector\u0026lt;int\u0026gt; \u0026amp;A,int B) { vector\u0026lt;int\u0026gt; C; for(int i = 0,t =0;i \u0026lt; A.size() || t != 0;i++)//t != 0确保最高位进位 { if(i \u0026lt; A.size()) t = t + A[i] * B; C.push_back(t%10); t = t/10; } while(C.size() \u0026gt; 1 \u0026amp;\u0026amp; C.back() == 0)C.pop_back();//出现一个乘数为0的情况。 return C; } 除法 # 除法也是模拟的方法。不过细节稍微有点不同。\nvector\u0026lt;int\u0026gt; divBigInteger(vector\u0026lt;int\u0026gt; A,int B,int \u0026amp;d) { vector\u0026lt;int\u0026gt; C; d = 0; for(int i = A.size() - 1; i \u0026gt;=0;i--)//除法是从最高位开始除的，所以这里从最高位开始。 { d = A[i] + d*10;//列式除法最下方那个数字 C.push_back(d / B);//列式除法最上方那一行的数字入C； d = d % B;//算完后的余数，留给下一位计算。 } reverse(C.begin(),C.end());//由于C是正向加入，所以这里翻转。 while(C.size() \u0026gt; 1 \u0026amp;\u0026amp; C.back() == 0) C.pop_back();//除去前导0 return C; } 前缀和 # 前缀和是指用一个数组来存前i个数据的和，这样方便计算区间和的值。\n一维前缀和 # const int N = 100010; int s[N]; int a[N]; for(int i = 1; i \u0026lt;= n ;i++) { s[i] = s[i - 1] + a[i]; } 当要计算区间l到r的和时。\nprintf(\u0026#34;%d\u0026#34;,s[r] - s[l - 1]); 二维前缀和 # 计算前缀和数组\nconst int N = 1010; int a[N][N]; int s[N][N]; for(int i = 1;i \u0026lt;= n ;i++){ for(int j = 1;j \u0026lt;= m ;j++){ s[i][j] = a[i][j] + s[i][j - 1] + s[i-1][j] - s[i-1][j-1]; } } 求区间(i,j)到(k,l)内矩形内的和\nprintf(\u0026#34;%d\\n\u0026#34;,s[k][l] - s[k][j - 1] - s[i - 1][l] + s[i - 1][j - 1]); 差分 # 差分是指用一个数组来存相邻数的差，这样方便处理对区间内的数都加上某个数的操作。\n一维差分 # 定义插入函数\nconst int N = 100010; int arr[N]; int b[N]; void insert(int l,int r,int c) { b[l] += c; b[r + 1] -= c; } 区间内减去C\nb[l] = b[l] + c; b[r + 1] = b[r + 1] - c; ``` 求原数组，输出结果 ```cpp for(int i = 1;i \u0026lt;= n ;i++) { b[i] += b[i-1]; } for(int i = 1;i \u0026lt;= n ;i++) { printf(\u0026#34;%d \u0026#34;,b[i]); } 二维差分 # 定义插入函数\nconst int N = 1010; int n,m,q; int arr[N][N]; int b[N][N]; void insert(int x1,int y1,int x2,int y2,int c){ b[x1][y1] += c; b[x2 + 1][y1] -= c; b[x1][y2 + 1] -= c; b[x2 + 1][y2 + 1] += c; } 计算差分数组。\nwhile(q--){ int x1,x2,y1,y2,c; scanf(\u0026#34;%d%d%d%d%d\u0026#34;,\u0026amp;x1,\u0026amp;y1,\u0026amp;x2,\u0026amp;y2,\u0026amp;c); insert(x1,y1,x2,y2,c); } 逆运算求原数组并输出。\nfor(int i = 1; i\u0026lt;=n;i++) for(int j = 1;j\u0026lt;=m;j++){ b[i][j] += b[i-1][j] + b[i][j-1] - b[i-1][j-1]; } for(int i = 1;i \u0026lt;= n;i++){ for(int j = 1; j\u0026lt;=m;j++){ printf(\u0026#34;%d \u0026#34;,b[i][j]); } printf(\u0026#34;\\n\u0026#34;); } 双指针算法 # 一般用i,j两个指针来遍历数组。快速排序也使用了双指针的思想。 核心思想：\n将下面的朴素算法$O(n^2)$优化到$O(n)$\nfor(int i = 0;i\u0026lt;n;i++) { for(int j = 0; j \u0026lt; n ;j ++){ //具体逻辑 check(i,j); } } 基本模板：\nfor(int i = 0,j=0;i\u0026lt;n;i++) { while(i \u0026lt; j\u0026amp;\u0026amp;check(i,j))j++; //具体逻辑 } 求最长不重复子列长度 # 数组不含重复数字的最长子列的长度。 朴素做法是遍历所有i，j。但是根据分析后发现，如果区间内无重复子列，i往后移动出现了重复子列，那么j只有往后移动才可能消去这个子列。往左则不满足i移动前的条件，即当前是最长无重复子列。\nint a[N]; int s[N];//用于确定区间内是否有重复数组，这也可以使用哈希表来判断。 for(int i = 0,j = 0;i \u0026lt; n;i++){ s[a[i]] ++ ; while(s[a[i]] \u0026gt; 1){ //如果存在重复数，则j往前移动 //为什么不往后移动？因为当前j已经是满足上一个i的最右距离，只能往左了。 s[a[j]] --; j ++; } res = max(res,i - j + 1); } 位运算 # 常用操作 # 求n的二进制数的第k位，和第一个1的位置。\nint res = n\u0026gt;\u0026gt;k \u0026amp; 1;//将第k位右移到个位，然后与000001进行和运算。个位为1输出1否则输出0。 int lowbit(int n){ return n\u0026amp;(-n); //return n\u0026amp;(~x + 1); } int num = lowbit(n); 用例 判断一个数的二进制数有多少个1。\nint num = 0; while(x \u0026gt; 0){ x -= lowbit(x); num ++; } printf(\u0026#34;%d \u0026#34;,num); 离散化 # 主要思想 # 在一个长区间，是很长很长的区间中，存在零散的数据。这种情况下找区间内的值，如果一个个遍历会很费时（因为区间很长），所以有了离散化的想法。\n一般是将数据依照顺序来与自然数一一对应.如果有区间那么也添加到其中.\n以一个题目为例: 802. 区间和 - AcWing题库\n全部代码 # #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; typedef pair\u0026lt;int, int\u0026gt; PII; const int N = 300010; int n, m; int a[N], s[N];//定义离散化后的数组,与前缀和数组. vector\u0026lt;int\u0026gt; alls;//存储需要离散化的值,并将其与自然数映射. vector\u0026lt;PII\u0026gt; add, query;//存储添加数据对,与查询数据范围. int find(int x)//根据离散化的数查询自然数对应的位置. { int l = 0, r = alls.size() - 1; while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (alls[mid] \u0026gt;= x) r = mid; else l = mid + 1; } return r + 1;//因为要使用前缀和,所以一般数组以1开头,所以这里加一. } int main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 0; i \u0026lt; n; i ++ ) { int x, c; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; c; add.push_back({x, c}); alls.push_back(x);// } for (int i = 0; i \u0026lt; m; i ++ ) { int l, r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; query.push_back({l, r}); alls.push_back(l); alls.push_back(r); } // 去重 sort(alls.begin(), alls.end()); alls.erase(unique(alls.begin(), alls.end()), alls.end()); //担心一个点加两次数却被去重? //这里只存储位置,加数在后边遍历添加数据对中, //如果一个点多加两次,那么add中也有两条对应的. // 处理插入 for (auto item : add) { int x = find(item.first); a[x] += item.second; } // 预处理前缀和 for (int i = 1; i \u0026lt;= alls.size(); i ++ ) s[i] = s[i - 1] + a[i]; // 处理询问 for (auto item : query) { int l = find(item.first), r = find(item.second); cout \u0026lt;\u0026lt; s[r] - s[l - 1] \u0026lt;\u0026lt; endl; } return 0; } 区间合并 # 问题提出 # 给出n个区间范围,如果区间有公共范围,则合并.求最终剩下几个区间.\n主要思路 # 可以按照左端点大小进行排序,然后检查右端点与下一个区间的左端点的关系,如果包含则并入,否则不处理,划分到下一个区间,\n主要代码 # #include\u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; const int N = 100010; typedef pair\u0026lt;int,int\u0026gt; PAIR; vector\u0026lt;PAIR\u0026gt; seg; void merged(vector\u0026lt;PAIR\u0026gt;\u0026amp; seg){ vector\u0026lt;PAIR\u0026gt; res; int st, ed; st = -2e9; ed = -2e9; sort(seg.begin(),seg.end()); for(auto item:seg){ if(ed \u0026lt; item.first){ if(ed != -2e9){ res.push_back({st,ed}); } st = item.first; ed = item.second; }else ed = max(ed,item.second); } if(st != -2e9) res.push_back({st,ed}); seg = res; } int main(){ int n; cin \u0026gt;\u0026gt; n; for(int i = 0 ; i \u0026lt; n ;i ++){ int l , r; cin \u0026gt;\u0026gt; l \u0026gt;\u0026gt; r; seg.push_back({l,r}); } merged(seg); cout \u0026lt;\u0026lt; seg.size(); return 0; } 大概就是这样了\n","externalUrl":null,"permalink":"/posts/chapter02/acwing/base/base-1/","section":"Posts","summary":"快速排序 # 主要思想: # 在数组中选择一个值，然后遍历数组，比这个值大的放到这个值后边，比这个值小的放到这个值的前边。","title":"基础算法一","type":"posts"},{"content":"","externalUrl":null,"permalink":"/posts/chapter02/commonsolution/","section":"Posts","summary":"","title":"常用思想方法","type":"posts"},{"content":"人们可以因为完全不同的原因对同一个人产生兴趣，并把他安插到各自生命的故事中的不同位置上。\n科学只有一个目标，就是去知道，它不会考虑欲望、负罪感和享乐(jouissance)。对此，拉康说道：“科学会对所谓的人性造成一种不可呼吸的效果。”而精神分析相比科学的话语，处在例外的位置，它具有一种“人工肺的功能”。相比科学普遍化的尝试，精神分析的伦理学强调个体差异和每个人的独特性，这方面极端的例子是对于一些严重的精神病患者，有些分析家会主张针对每一个主体发明一种适合他的诊断，而不是将他对应到某个现有的诊断中。\n精神分析能够利用到自身，对人性的反应。\n三条岔路 # 另一个女人和男\u0026quot;工具人\u0026quot; # ","externalUrl":null,"permalink":"/posts/notes/readingnotes/0002/","section":"Posts","summary":"人们可以因为完全不同的原因对同一个人产生兴趣，并把他安插到各自生命的故事中的不同位置上。","title":"拉康","type":"posts"},{"content":" 图论 # Floyd算法 # 主要思想是: 循环邻接矩阵中查找每个点到另外一个点的最短距离，不仅是看直接距离，也还要通过计算中转点。比如计算A到B的距离，要比较A到C的距离与C到B的距离的和、A到B的直接距离的最小值来判断，中转点可以是其他节点，所以代码实现中出现了三重循环。\n//n为顶点个数 //第一轮循环为 选取中间点的个数 //第二三轮循环为 void floyd(){ for(int k = 1 ; k \u0026lt;=n ; k++) for(int i = 1 ; i \u0026lt;= n ;i ++) for(int j = 1 ; j \u0026lt;=n ;j ++) dic[i][j] = min(dic[i][j],dic[i][k] + dic[k][j]); } 模板题代码：\n#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 210,INF = 1e9; int dic[N][N]; int n,m,Q; void floyd(){ for(int k = 1 ; k \u0026lt;=n ; k++) for(int i = 1 ; i \u0026lt;= n ;i ++) for(int j = 1 ; j \u0026lt;=n ;j ++) dic[i][j] = min(dic[i][j],dic[i][k] + dic[k][j]); } int main(){ scanf(\u0026#34;%d%d%d\u0026#34;,\u0026amp;n,\u0026amp;m,\u0026amp;Q); for(int i = 1 ; i \u0026lt;= n ;i ++) for(int j = 1 ; j\u0026lt;=n;j++) if(i == j) dic[i][j] = 0; else dic[i][j] = INF; while(m--) { int a,b,w; scanf(\u0026#34;%d%d%d\u0026#34;,\u0026amp;a,\u0026amp;b,\u0026amp;w); dic[a][b] = min(dic[a][b],w); } floyd(); while(Q--) { int a,b; scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;a,\u0026amp;b); if(dic[a][b] \u0026lt; INF / 2) printf(\u0026#34;%d\u0026#34;,dic[a][b]); else printf(\u0026#34;impossible\u0026#34;); printf(\u0026#34;\\n\u0026#34;); } return 0; } ","externalUrl":null,"permalink":"/posts/chapter02/acwing/base/search_and_graph/","section":"Posts","summary":"图论 # Floyd算法 # 主要思想是: 循环邻接矩阵中查找每个点到另外一个点的最短距离，不仅是看直接距离，也还要通过计算中转点。比如计算A到B的距离，要比较A到C的距离与C到B的距离的和、A到B的直接距离的最小值来判断，中转点可以是其他节点，所以代码实现中出现了三重循环。","title":"搜索与图论","type":"posts"},{"content":" 链表 # 拿数组模拟链表,其实也就是静态链表. 静态链表的优点是快,但是缺点是必须要提前分配足够空间,并且可能会出现假满状态,即idx到最后但是前边还有很多未使用的节点,\n单链表 # #include\u0026lt;iostream\u0026gt; using namespace std; const int N = 100010; int e[N]; int ne[N]; int idx,head; void init(){ head = -1; idx = 0; } void add_to_head(int x){ e[idx] = x; ne[idx] = head; head = idx++; } //插入到下标为k的后面 void add(int k,int x){ e[idx] = x; ne[idx] = ne[k]; ne[k] = idx ++; } void del(int k){ if(k == -1) head = ne[head]; else ne[k] = ne[ne[k]]; } int main(){ int m; cin \u0026gt;\u0026gt; m; init(); while(m--){ char opt; cin \u0026gt;\u0026gt; opt; if(opt == \u0026#39;H\u0026#39;){ int x; cin \u0026gt;\u0026gt; x; add_to_head(x); }else if(opt == \u0026#39;D\u0026#39;){ int k; cin \u0026gt;\u0026gt; k; del(k-1); }else{ int k,x; cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt;x; add(k - 1,x); } } int index = head; while(index != -1){ cout \u0026lt;\u0026lt; e[index] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; index = ne[index]; } return 0; } 双链表 # 所谓双链表就是每个节点含有前结点位置进而后节点位置.\n#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 100010; int pre[N],ne[N],e[N]; int idx; // 定义0号位为头结点 // 定义1号位为尾结点 void init(){ ne[0] = 1; pre[0] = -1; ne[1] = -1; pre[1] = 0; idx = 2; } void add_head(int x){ e[idx] = x; ne[idx] = ne[0]; pre[idx] = 0; pre[ne[0]] = idx; ne[0] = idx; idx ++; } void add_tail(int x){ e[idx] = x; ne[idx] = 1; pre[idx] = pre[1]; ne[pre[1]] = idx; pre[1] = idx; idx++; } void del(int k){ ne[pre[k]] = ne[k]; pre[ne[k]] = pre[k]; } void add_left(int k,int x){ e[idx] = x; ne[idx] = k; pre[idx] = pre[k]; ne[pre[k]] = idx; pre[k] = idx; idx ++; } void add_right(int k,int x){ e[idx] = x; ne[idx] = ne[k]; pre[idx] = k; pre[ne[k]] = idx; ne[k] = idx; idx++; } int main(){ int m; cin \u0026gt;\u0026gt; m; init(); while(m --){ string opt; int k,x; cin \u0026gt;\u0026gt; opt; if(opt == \u0026#34;L\u0026#34;){ cin \u0026gt;\u0026gt; x; add_head(x); }if(opt == \u0026#34;R\u0026#34;){ cin \u0026gt;\u0026gt; x; add_tail(x); }if(opt == \u0026#34;D\u0026#34;){ cin \u0026gt;\u0026gt; k; del(k + 1); }if(opt == \u0026#34;IL\u0026#34;){ cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; x; add_left(k + 1,x); }if(opt == \u0026#34;IR\u0026#34;){ cin \u0026gt;\u0026gt; k \u0026gt;\u0026gt; x; add_right(k + 1,x); } } int j = 0; for(int i = ne[0]; ne[i] != -1; i = ne[i]){ cout\u0026lt;\u0026lt; e[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } return 0; } 栈和队列 # 使用数组实现基本的栈与队列\n模拟栈 # const int N = 1010; //栈 int stk[N],tt = -1; //入栈 stk[++tt] = elem; //出栈 stk[tt--]; //栈是否为空 if tt \u0026lt; 0 stack is empty else stack is not empty 完整操作代码\nconst int N = 100010; int stk[N],idx; //初始化 void init(){ idx = -1; } //插入元素 void push(int x){ stk[++idx] = x; } //取出栈顶元素 int pop(){ int res = stk[idx--]; return res; } //判断是否为空 bool isEmpty(){ if(idx \u0026lt; 0) return true; else return false; } //获取栈顶元素 int pull(){ return stk[idx]; } 模拟队列 # const int N = 1010; //栈 int queue[N],tt,hh; //入队 queue[tail++] = elem; //出队 queue[top++]; 完整操作\nconst int N = 100010; int queue[N],top,tail; //初始化 void init(){ top = -1; tail = -1; } //插入元素到队尾 void push(int x){ queue[++tail] = x; } //弹出队列队首元素 int pop(){ int res = queue[++top]; return res; } //队列是否空 bool isEmpty(){ if(top \u0026gt;= tail) return true; else return false; } //返回队列队首元素 int pull(){ return queue[top + 1]; } 单调栈与单调队列 # 单调栈 # 定义 # 什么是单调栈? 栈中的数据具有单调性.现在有一组数10,3,7,4,12从左到右依次入栈，则如果栈为空或入栈元素值小于栈顶元素值，则入栈；否则，如果入栈则会破坏栈的单调性，则需要把比入栈元素小的元素全部出栈。单调递减的栈反之。\n应用场景 # 给定一个序列,求每个元素左边(或右边)最近的比它小(或大)的元素.其实就是找逆序对,最近的两个构成逆序就输出,未找到就返回-1.\n如下图所示, 4找3,满足,则返回3; 2往前找4,不满足,找3,也不满足,则返回-1; 7往前找2(如果2满足,则无需考虑2之前的数据),满足则返回2. 5往前找7,不满足,则去找2,满足,则返回2. 如果满足逆序则保留,不满足则不保留 (因为如果保留,则当前点不满足,上一个点也不满足,需要多遍历, 例如序列5 4 3 1 2, 考虑3时,5 4是非逆序,那么4不满足,5同样不满足) 这种情况使用栈最好,因为考虑的数据是按照后进先出的顺序读取.\n主要代码 # #include\u0026lt;iostream\u0026gt; using namespace std; const int N = 10010; int stk[N].idx = 0; int main(){ int n; cin \u0026gt;\u0026gt; n; for(int i = 0 ; i \u0026lt; n ; i++){ int x; cin \u0026gt;\u0026gt; x; while(idx \u0026amp;\u0026amp; stk[idx] \u0026gt;= x) idx--; if(idx) cout \u0026lt;\u0026lt; stk[idx] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;-1\u0026#34; \u0026lt;\u0026lt; \u0026#34; \u0026#34;; stk[++idx] = x; } return 0; } 单调队列 # 定义 # 什么是单调队列? 有单调性的队列!\n应用场景 # 输入一个数组,并且有长度为k的滑动窗口不断向右移动,求每移动一次后窗口中元素的最大(小)值.滑动窗口求最值.\n先考虑暴力解法,再进行优化,考虑哪些没有用到却被操作.\n#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1000010; int n,k; int a[N],q[N]; int hh,tt; int main(){ scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;n,\u0026amp;k); for(int i = 0 ; i \u0026lt; n ; i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i]); int hh = 0, tt = 0; for(int i = 0 ; i \u0026lt; n ; i++ ){ //判断队头是否已经滑出窗口,即当窗口长度为3时 //,i = 3,hh = 0时,这个3长度的窗口 已经不包括 队首了 所以需要hh++ //一般情况只需要加一次,所以用的是if 不是while if(hh \u0026lt;= tt \u0026amp;\u0026amp; i - k + 1 \u0026gt; q[hh]) hh++; //队列如果加入新元素后不是单调的,就要出队, //直到满足队列为单调的 // 比如 当前窗口内为 3 -1 -3 , //那么3 -1 就是属于无效数据,因为-3是最小的 //在往后移动的过程中,只要有-3 前边都不考虑 //这种情况 也可以看成 不满足单调性 while(hh \u0026lt;= tt \u0026amp;\u0026amp; a[q[tt]] \u0026gt;= a[i]) tt--; //入队新元素 q[++tt] = i; //只要过了k个数 就要输出队头元素 if(i \u0026gt;= k - 1) printf(\u0026#34;%d \u0026#34;,a[q[hh]]); } printf(\u0026#34;\\n\u0026#34;); hh = tt = 0; for(int i = 0 ; i \u0026lt; n ; i ++){ if(hh \u0026lt;= tt \u0026amp;\u0026amp; i - k + 1 \u0026gt; q[hh]) hh++; while(hh \u0026lt;= tt \u0026amp;\u0026amp; a[q[tt]]\u0026lt;= a[i]) tt--; q[++tt] = i; if(i \u0026gt;= k - 1) printf(\u0026#34;%d \u0026#34;,a[q[hh]]); } return 0; } KMP # KMP是一种字符串匹配算法,该算法充分体现了利用已有信息降低操作数,即时间复杂度. 完整代码\n#include\u0026lt;iostream\u0026gt; using namespace std; const int M = 1e6 + 10, N = 1e5 + 10; //定义 字符串 str 与 模板串 ptn char str[M],ptn[N]; int n,m; // 定义next数组 int ne[N]; int main() { scanf(\u0026#34;%d%s%d%s\u0026#34;,\u0026amp;n,ptn + 1,\u0026amp;m,str+1); //next数组第一位是0 所以从第二位开始 // 计算next数组 for(int i = 2 , j = 0 ; i \u0026lt;= n ; i++) { // 如果j是0 就没办法再往前了 // 如果当前与 while(j \u0026amp;\u0026amp; ptn[i] != ptn[j + 1])j = ne[j]; if(ptn[i] == ptn[j+1]) j ++; ne[i] = j; } for(int i = 1 , j = 0 ; i \u0026lt;= m ; i++) { while(j \u0026amp;\u0026amp; str[i] != ptn[j + 1]) j = ne[j]; if(str[i] == ptn[j + 1]) j ++; if(j == n) { printf(\u0026#34;%d \u0026#34;,i - n); j = ne[j]; } } return 0; } Trie树(字典树) # “Trie这个名字取自“retrieval”，检索，因为Trie可以只用一个前缀便可以在一部字典中找到想要的单词。”\n什么是Trie树 # 高效地存储与查找字符串集合的数据结构.用树结构来存储字符串集合,举例: 对于某字符串集合{\u0026quot;abcde\u0026quot;,\u0026quot;abdcf\u0026quot;,\u0026quot;acde\u0026quot;,\u0026quot;acfd\u0026quot;,\u0026quot;abc\u0026quot;,\u0026quot;bd\u0026quot;}.有下面这种存储方法.带星号表示从头往下查找到这个地方算一个字符串, 基本思想 # 如果是存小写字母组成的字符串集合,那么a-z对应的是0-25,如果是大写字母或其他情况同理.每次新加一个字符串中的一个字符,都要给这个字符上一个序号idx.每个需要都要记录它的子节点.比如son[idx][u]记录了序号为idx的子节点u的下一个节点指向的序号.\n打个比方:字符串abcd存入时有这种情况\nson[0][\u0026#39;a\u0026#39; - \u0026#39;a\u0026#39;] = 1;//初始节点的后继节点a的序号是1 son[1][\u0026#39;b\u0026#39; - \u0026#39;a\u0026#39;] = 2;//序号为1的后继节点b的序号是2 son[2][\u0026#39;c\u0026#39; - \u0026#39;a\u0026#39;] = 3;//序号为2的后继节点c的序号是3 son[3][\u0026#39;d\u0026#39; - \u0026#39;a\u0026#39;] = 4;//序号为3的后继节点d的序号是4 如果我继续存入abcf\nson[0][\u0026#39;a\u0026#39; - \u0026#39;a\u0026#39;] = 1;//初始节点的后继节点a的序号是1 son[1][\u0026#39;b\u0026#39; - \u0026#39;a\u0026#39;] = 2;//序号为1的后继节点b的序号是2 son[2][\u0026#39;c\u0026#39; - \u0026#39;a\u0026#39;] = 3;//序号为2的后继节点c的序号是3 //abcf中abc节点都已经存过,所以不需要增加序号 //f属于abc这一子树的新节点,所以需要赋予新序号5 //如果要查找abcf后续节点x,则需要从5开始 //即son[5][x - \u0026#39;a\u0026#39;] = idx; idx表示 x 的序号,如果不存在则为0; son[3][\u0026#39;f\u0026#39; - \u0026#39;a\u0026#39;] = 5;//序号为3的后继节点f的序号是5 那么又一个问题来了。我怎么知道往下哪个是字符串结束呢？比如我存入abc和abcd两个字符串。怎么判断abc在里面。这里我们使用一个cnt[p]数组，该数组存的是以序号p的字符结尾的字符串个数. 。 依托这个数组,我们可以得到在字符串集合{\u0026quot;abc\u0026quot;,\u0026quot;abcd\u0026quot;}中cnt[3] = 1; cnt[4] = 1;代表以字符序号为3和4结尾的字符串各出现了一次.\n主要代码 # #include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1e5 + 10; //son[i][j] 表示编号为i的j儿子的后继节点数 int son[N][26],cnt[N]; char str[N]; int n,idx; void insert(char x[]) { int p = 0; for(int i = 0 ; x[i] ;i++) { int u = x[i] - \u0026#39;a\u0026#39;; //如果不存在节点，则新建一个，然后新节点标号为++idx。 //++idx表示给新节点上个序号,盖个出生证明 if(!son[p][u]) son[p][u] = ++idx; //如何找到下一个节点? //son[p][u]为节点序号为 //p的节点的子节点为u的节点的下一个节点序号 p = son[p][u]; } //表示以节点序号为p结尾的字符串个数. cnt[p] ++; } int query(char x[]) { int p = 0; for(int i = 0 ; x[i] ; i++) { int u = x[i] - \u0026#39;a\u0026#39;; if(!son[p][u]) return 0 ; p = son[p][u]; } return cnt[p]; } int main() { scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); while(n --){ char opt; cin \u0026gt;\u0026gt; opt \u0026gt;\u0026gt; str; if(opt == \u0026#39;I\u0026#39;)insert(str); else printf(\u0026#34;%d\\n\u0026#34;,query(str)); } return 0; } 并查集 # 应用场景 # 适用于维护集合之间的合并，与查询两个数是否在同一个集合内的情况。\n核心代码 # int p[N]; // 压缩路径版本 // 即每次查询 都将集合中的节点指向根节点 int find(int x){ if (p[x] != x) p[x] = find(p[x]); return p[x]; } // 预处理，代表每一个数都属于单独的集合，集合编号为i for(int i = 1 ; i \u0026lt;= n ; i++) p[i] = i; //合并操作 void merge(int a,int b) { p[find(a)] = find(b); } //查询操作 void query(int a,int b) { if(find(a) == find(b)) puts(\u0026#34;Yes\u0026#34;); else puts(\u0026#34;No\u0026#34;); } 哈希表 # 哈希表存储结构 # 将一个集合中的数通过一个函数映射到另外一个集合中。例如离散化中，将大范围中的数据映射到小范围的区间上，这是一种哈希映射，但这种映射需要保存前后顺序，属于特殊的哈希映射。哈希表一般指比较一般情况下的映射。\n但是哈希映射函数可能会出现哈希冲突的情况，比如有一个数据范围为0~1e9的数组，映射到0~1e5范围内，使用的映射函数为h(x) = x MOD 1e5，这种情况可能会出现某两个数经过哈希映射函数计算的哈希值相同，就发生了冲突。这就是所谓的哈希冲突，解决哈希冲突一般有两种方法：开放寻址法和拉链法。\n开放寻址法 # 所谓开放寻址，就是某个点如果发生哈希冲突，就在这个点哈希值加一位置插入数据，如果这个点还有数，就继续往后加，直到为空。\n#include\u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; //一般取质数情况下，发生哈希冲突的概率较低。 //开放寻址法 一般要数组开大一点. //因为h[N]存的是哈希值为N的值是多少 const int N = 200003,null = 0x3f3f3f3f; //按位寻址法 int h[N]; int find(int x) { //负数模后是负数，所以加N int k = (x % N + N) % N; while(h[k] != null \u0026amp;\u0026amp; h[k] != x){ k++; //找到头还没找到 就从0开始 //一般不会出现找不到的情况，有的话就把数组开大 if(k == N) k = 0; } return k; } int main(){ int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); //初始化全部为null 以便标记该位置没存过数 memset (h, null , sizeof h); while(n --) { char opt[2]; int x; scanf(\u0026#34;%s%d\u0026#34;,opt,\u0026amp;x); //先找到位置，如果是没有的话就返回null。 //插入就是把null赋值为x //查找的话 是null就是没找到 int k = find(x); if(*opt == \u0026#39;I\u0026#39;) h[k] = x; else { if(h[k] != null) puts(\u0026#34;Yes\u0026#34;); else puts(\u0026#34;No\u0026#34;); } } return 0; } 拉链法 # 所谓拉链法，就是某个点如果发生哈希冲突，就在这个点上建立一个链表，然后把数加到链表上。\n#include\u0026lt;iostream\u0026gt; #include \u0026lt;cstring\u0026gt; using namespace std; //一般取质数情况下，发生哈希冲突的概率较低。 const int N = 100003; // 拉链法 //定义链表，e[idx]存序号为idx的数值，ne[idx]存序号为idx的下一项; // h[k]存哈希值为k的第一个数的idx序号 int h[N],e[N],ne[N],idx; void insert(int x) { //负数模后是负数，所以加N int k = (x % N + N) % N; e[idx] = x; ne[idx] = h[k]; h[k] = idx ++; } bool find(int x) { int k = (x % N + N) % N; for(int i = h[k]; i != -1 ; i = ne[i]) { if(e[i] == x) return true; } return false; } int main(){ int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); //初始化全部为-1 以便标记为空 memset (h, -1 , sizeof h); while(n --) { char opt[2]; int x; scanf(\u0026#34;%s%d\u0026#34;,opt,\u0026amp;x); if(*opt == \u0026#39;I\u0026#39;) insert(x); else { if(find(x)) puts(\u0026#34;Yes\u0026#34;); else puts(\u0026#34;No\u0026#34;); } } return 0; } 字符串哈希 # 将字符串转换为一串数字然后计算哈希值存入哈希表，如abcde中每个字母对应的ASCII码中的编号按顺序为1 2 3 4 5（计算方法为'a' - 'a' + 1，'b' - 'a' + 1，'c' - 'a' + 1等）那么可以将这段数字转换为P进制数，这样就可以区分不同字符串对应的哈希值。但是如果字符串位数比较多，会出现哈希值溢出的情况，那么就需要取模Q运算！\n//一般情况下 P = 131;//P = 131; Q = 1 \u0026lt;\u0026lt; 64; 也可以利用这个算法实现前缀哈希，即某个字符串前i位的哈希值。然后我们就可以通过这个数组计算某个子串的哈希值。\n","externalUrl":null,"permalink":"/posts/chapter02/acwing/base/datestruct/","section":"Posts","summary":"链表 # 拿数组模拟链表,其实也就是静态链表.","title":"数据结构","type":"posts"},{"content":" 质数 # 针对所有大于1的自然数定义的，只包含1和本身两个约数的自然数叫做质数（素数）。\n质数的判定 # 试除法 # bool is_prime(int n){ if(n \u0026lt; 2) return false; for(int i = 2; i \u0026lt;= n ; i++){ if(n % i == 0) return false; } return true; } O(n); 如果i包含其他因子，那么这因子应该是成双成对出现的。比如12的因子有{1,2,3,4,6,12}。 这里只需要遍历成对中的第一个就可以了， 如果n可以被d整除，证明d是n的一个因子，那么另外一个与其对应的因子是n除以n除以d的商。所以我只需要遍历到第一个因子就可以了，即d满足大于n除以d的商，d大于根号n就OK。时间复杂度可以降到根号n。\nbool is_prime(int n){ if(n \u0026lt; 2) return false; for(int i = 2; i \u0026lt;= n / i ; i++){ if(n % i == 0) return false; } return true; } O(sqrt(n)); 不使用sqrt(i)可以降低时间复杂度，每次循环都会计算一次。如果使用i * i \u0026lt;= n，则可能存在 i * i溢出风险，变成负值。\n分解质因数 # 什么是质因数？\n一个数的某对因子均为质数。比如6的因子有2和3，这对因子就是质因数。 从小到大枚举所有约数。\n试除法 # void divide(int n){ for(int i = 2; i \u0026lt;= n; i++) { if(n % i == 0) { } } } ","externalUrl":null,"permalink":"/posts/chapter02/acwing/math/shulun/","section":"Posts","summary":"质数 # 针对所有大于1的自然数定义的，只包含1和本身两个约数的自然数叫做质数（素数）。","title":"数论","type":"posts"},{"content":"记得东西有些杂乱，可以细分一下内容，归类，然后有空的时候整理一下，maybe换个主题？\n关于生活的意义， 且听下回分解！\n只喜欢一面，那只是占有欲啊！不是爱\n我在想什么?! 好没用啊 明明我之前也不是这样的 这是不想承认自己不行吗\n如果你想找回思考能力，可以尝试阅读一些挑战思维的书籍，如哲学、经济学、物理学、心理学等领域的经典著作。以下是一些建议：\n哲学类：柏拉图的《理想国》、尼采的《查拉图斯特拉如是说》、笛卡尔的《第一哲学沉思》等。 经济学类：亚当·斯密的《国富论》、约翰·梅纳德·凯恩斯的《就业、利息和货币通论》等。 物理学类：艾萨克·牛顿的《自然哲学的数学原理》、爱因斯坦的《相对论》等。 心理学类：弗洛伊德的《精神分析导论》、卡尔·罗杰斯的《成为人》等。 这些书籍可以激发你的思维，让你思考一些深层次的问题，提高你的逻辑思考和判断能力。当然，也可以选择其他类型的书籍，只要是能够激发你思维的书籍都可以尝试阅读。\n能够激发思维的书籍是指这些书籍可以激发读者的思维，让读者思考一些问题，探索一些新的想法，从而提升读者的认知水平和思考能力。这些书籍通常包含深刻的洞见、新颖的观点、严密的逻辑和清晰的语言表达。它们可以引发读者的兴趣，激发读者的好奇心和探究欲望，促使读者主动思考和探索。这些书籍不仅可以扩展读者的知识面，还可以提高读者的思考能力和思维方式。\n","externalUrl":null,"permalink":"/posts/notes/thinknote/00003/","section":"Posts","summary":"记得东西有些杂乱，可以细分一下内容，归类，然后有空的时候整理一下，maybe换个主题？","title":"生活","type":"posts"},{"content":" 数据结构 # vector[可变数组] # vector是一种变长数组，即可以自动改变长度的数组。 头文件\n#include\u0026lt;vector\u0026gt; 初始化\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; using namespace std; int main () { //几种初始化的方法 vector\u0026lt;int\u0026gt; a;//定义一个vector 未初始化 输出》 0 vector\u0026lt;int\u0026gt; a(3);//定义一个长度为3的vector 未初始化 输出》0 0 0 vector\u0026lt;int\u0026gt; a(10, 3); //定义一个长度为10，且每个数赋值为3 //将向量b中从下标0 1 2（共三个）的元素赋值给a，a的类型为int型 //它的初始化不和数组一样 vector\u0026lt;int\u0026gt;a(b.begin(),b.begin+3); //从数组中获得初值 int b[7]={1,2,3,4,5,6,7}; vector\u0026lt;int\u0026gt; a(b,b+7）; for(auto x : a) {//遍历输出 cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } return 0; } 相关函数\na.size();//返回元素个数 a.resize();//改变大小 a.empty();//判断a是否为空，空则返回true，非空则返回false a.front(); //返回a的第1个元素,当且仅当a存在 a.back(); //返回vector的最后一个数 a.clear(); //清空a中的元素 a.pop_back(); //删除a向量的最后一个元素 a.push_back(5); //在a的最后一个向量后插入一个元素，其值为5 a.begin();// vector的第0个数 a.end();// vector的最后一个的数的后面一个数 //通常与for循环结合使用 ⑦倍增的思想\n[C++]系统为某一程序分配空间的所需时间，与空间大小无关，与申请次数有关如申请一个空间为1000 和 空间为1 申请1000次的所需时间差别是很大的，申请次数越多，越耗时间 支持比较运算 比较操作如==，！=，\u0026lt;，\u0026lt;，\u0026lt;=，\u0026gt;，\u0026gt;=\nint main () { //支持比较运算 vector\u0026lt;int\u0026gt; a(4, 3), b(3, 4); //a: 3 3 3 3 b:4 4 4 //比较原理字典序 (根据最前面那个判断，如果一样就往后比较) if (a \u0026lt; b) { puts(\u0026#34;a \u0026lt; b\u0026#34;); } return 0; } 遍历方法\nint main () { vector\u0026lt;int\u0026gt; a; for (int i = 0; i \u0026lt; 10; i ++) { a.push_back(i); } //三种遍历vector的方法 for (int i = 0; i \u0026lt; a.size(); i ++) { cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } cout \u0026lt;\u0026lt; endl; for (auto i = a.begin(); i != a.end(); i ++) { cout \u0026lt;\u0026lt; *i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } cout \u0026lt;\u0026lt; endl; //C++11的新语法 for (auto x : a) { cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } cout \u0026lt;\u0026lt; endl; return 0; } 结合算法库中的erase() reverse()\na.erase(p)//从a中删除迭代器p指定的元素，p必须指向c中的一个真实元素，不能是最后一个元素end() a.erase(b,e)//从a中删除迭代器对b和e所表示的范围中的元素，返回e vector\u0026lt;int\u0026gt; a={1,2,3,4,5}; reverse(a.begin(),a.end());//a的值为5，4，3，2，1 倒置 string[字符串] # 支持比较运算 比较操作如==，！=，\u0026lt;，\u0026lt;，\u0026lt;=，\u0026gt;，\u0026gt;= 头文件\n#include\u0026lt;string\u0026gt; 初始化\nstring a = \u0026#34;abc\u0026#34;; queue[队列]和priority_queue[优先队列，堆] # stack[栈] # deque[双向队列] # set[集合]和multiset # set（集合），是一个内部自动有序且不含重复元素的容器。 set可以在需要去重复元素的情况大放异彩，节省时间，减少思维量。 要使用set，需要添加头文件： 头文件\n#include\u0026lt;set\u0026gt; 初始化\nset\u0026lt;int\u0026gt; gather; map[映射]和multiset # unordered[哈希表] # bitset[压位] # 算法 # Algorithm[常用算法函数] # 其他 # C++ pair的基本用法总结（整理） - 知乎 `\n","externalUrl":null,"permalink":"/posts/chapter01/argo-datastru/","section":"Posts","summary":"数据结构 # vector[可变数组] # vector是一种变长数组，即可以自动改变长度的数组。 头文件","title":"算法竞赛常用STL","type":"posts"},{"content":" 01 背包问题 # 每件物品最多只用一次。\n有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。 第 i 件物品的体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。\n输出最大价值。 2. 01背包问题 - AcWing题库\n#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1010; int v[N],w[N]; int m,n; int f[N][N]; int main(){ cin \u0026gt;\u0026gt; m \u0026gt;\u0026gt; n; for(int i = 1; i \u0026lt;= m;i++ ){ cin \u0026gt;\u0026gt; v[i] \u0026gt;\u0026gt; w[i]; } for(int i = 1; i \u0026lt;= m;i++){ for(int j = 0;j\u0026lt;= n;j++) { f[i][j] = f[i - 1][j]; if( j \u0026gt;= v[i]) //当可以装下的空间比第i个大才有可能存在装第i个物品的情况。 f[i][j] = max(f[i][j],f[i - 1][j - v[i]] + w[i]); } } cout \u0026lt;\u0026lt; f[m][n]; return 0; } 优化为二维\n#include\u0026lt;iostream\u0026gt; using namespace std; 状态表示 # f(i,j) 表示从前i个背包中选，选出的总权值小于等于j的集合。 f(i,j)的值为总价值。\n集合 条件 只从前i中选 选出来的总权值 \u0026lt;j的集合 属性：最大值、最小值、数量。 状态计算 # 表示集合的划分 f(i,j)表示\n不包含第i个背包的最优解即f(i-1,j)， 包含第i个背包的最优解即f(i-1,j-w[i])+v[i]。即去掉第i个物品以及总权值减去第i个的权值。 总结： # 第i个背包能不能放，能放就是集合划分第二种，不能放就是第一种。从一步开始走，然后逐渐解决全部问题。\n完全背包 # 每件物品可以用很多次。\n整数划分\n#include\u0026lt;iostream\u0026gt; using namespace std; const int N = 1000010,MOD = 1e9; int f[N]; int main(){ int m; cin \u0026lt;\u0026lt; m; f[0] = 1; for(int i = 1; i \u0026amp;lt;= m;i *= 2){ for(int j = i; j \u0026amp;lt;= m ;j++){ f[j] = (f[j] + f[j - i]) % MOD; } } cout \u0026gt;\u0026gt; f[m]; return 0; } 多重背包 # 每件物品\n分组背包 # 有很多组，每组有多种\n","externalUrl":null,"permalink":"/posts/chapter02/acwing/dp/package/","section":"Posts","summary":"01 背包问题 # 每件物品最多只用一次。","title":"背包问题","type":"posts"},{"content":" 与区间有关的问题 # ","externalUrl":null,"permalink":"/posts/chapter02/acwing/base/greedy/","section":"Posts","summary":" 与区间有关的问题 # ","title":"贪心","type":"posts"}]